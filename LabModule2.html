<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report: Drawing Fractal Curves</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Drawing Fractal Curves</h1>
    <p class="author">
      [Leigh Brawner] <br />
      [February 20th, 2025]
    </p>
  </header>
  



  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This Fractal Geometry Lab Report focuses on drawing fractal curves using turtle Python. 
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>
        <p>
          Below is the Colab section showcasing some simple Python programs.
        </p>

        <figure>
          <img
            src="Lab Module 2 Image 2.1 Library Code.png"
            alt="Library Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Library Code
          </figcaption>
        </figure>

	<p>
	Figure 1 shows the code for installing the library associated to this module. This installs the turtle library as stated so that we can implement commands specific to turtle.
</p> 
	      <p>
Line 2: this line uses the !wget command, which is a command-line tool for downloading files from the internet. In this context, it's used within the Jupyter Notebook to download a Python script called turtle_setup.py.
-O turtle_setup.py specifies that the downloaded file should be saved with the name turtle_setup.py.
'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py' is the URL from where the turtle_setup.py script is downloaded. It's hosted on GitHub.
	
	</p>      
<p>Line 3: this implements from and import so that we can use the script downloaded from turtle_setup.py. Note that * means ‘all’, so that all functions and definitions from said script will be available for use. </p>
	      
	<figure>
          <img
            src="Lab Module 2 Image 2.2 Brownian Motion Code.png"
            alt="Original Brownian Motion Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Original Brownian Motion Code
          </figcaption>
        </figure>

	 <p> 
	 Figure 2 shows the original Brownian Motion Code provided.
	 </p>     
<p>
	Line 1: import sets up helper functions, i.e., enables us to access code from one module to another module to use functions, classes, and variables defined in other files. Here, we import random for later use in line 17 to help create Brownian motion.
</p>
<p>
Lines 4 & 5: we initialize (activate) the turtle canvas, which is fundamentally the overall area the turtle will use for creation of shapes. We assign total canvas width in line 4, and total canvas height in line 5; associated integer values assigned to these variables can be altered. Instead of canvas_width or canvas_length, we could have easily titled them width and height, provided consistency is maintained throughout the entire program’s code.
</p>
<p>
Line 6: initializeTurtle is a custom function to set up a drawing canvas; initial_window_size specifies the starting dimensions of the window; canvas_width and canvas_height are variables defined in lines 4-5 and are assigned integer values (as explained previously), which can be changed, that determine overall canvas width and height in pixels; mode is an argument for function initializeTurtle, with the value ‘auto’ that automatically updates the canvas display after each drawing command.
</p>     
<p>
Lines 9-13: we create a function to perform a random walk (Brownian motion). Line 9 defines a variable which we title as random_walk() with two input parameters called steps and step_length. Line 10 uses speed(0) which sets the speed which our turtle draws, 0 being the fastest setting; as such, 0 turns off animation delays, whereas inters 1-10 represent other speed settings (from slowest to fastest) that retain the animation with possible delays in formation. Line 11 uses the function penup() to lift the turtle’s pen off the canvas to stop drawing. Line 12 uses jump() with two associated integer x-y canvas coordinates that can be changed with respect to overall canvas size; this effectively moves the turtle’s position. Since we used the penup() function previously in line 11, the turtle will not draw anything as it moves to a new location using jump(). Line 13 uses pendown(), which puts the turtle’s pen back down to begin drawing during the random walk in its new location determined by jump() in line 12.
</p>
<p>
Lines 15-17: we use a for loop to simulate the random walk under specified conditions. Line 15 begins the for loop in conjunction with the in range() function, which returns a sequence of numbers and ends at the designated number; here, this number is variable steps, which is an integer assigned later in line 20. Line 16 is part of the for loop, and uses forward(), which moves the drawing turtle forward according to the variable step_length, which is an integer assigned in line 21. Line 17 uses right() to rotate the turtle to the right by a designated number of degrees; here, we implement random.uniform(), which randomly generates an integer degree angle between -180 and 180. This random rotation successfully creates a random walk, thus generating the desired Brownian motion effect. 
</p>
<p>
Lines 20-21: we execute the random walk by determining the steps and step length involved necessary for the previously written for loop to work. Line 20 is variable steps, which is assigned to an integer value; the larger this value, the longer and more complex the random walk becomes. Line 21is variable step_length, which is assigned to an integer value; this is the overall length of each step taken. Many steps with a short step length will create a scribble effect; fewer steps with a longer step length will create a zoomed in effect, so to speak.
</p>
<p>
Line 26: this line implements the show() function. This simply displays the visual result of all previous code. 
</p>
	<figure>
          <img
            src="Lab Module 2 Image 2.2 Brownian Motion Result.png"
            alt="Original Brownian Motion Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Original Brownian Motion Result
          </figcaption>
        </figure>

         <p>
	Figure 3 shows the original result of the Brownian Motion Code.	 
	 </p>      


	<figure>
          <img
            src="Lab Module 2 Image 2.3 Code.png"
            alt="Original Code of Koch Curve (Order 1)"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Original Code of Koch Curve (Order 1)
          </figcaption>
        </figure>

         <p>
	Figure 4 is the original code of Koch Curve (Order 1).  
	 </p>     

<p>
Line 1: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas.
</p>

<p>
Line 2: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position.
</p>  

<p>
Line 4: jump() repositions the turtle to the specified x,y coordinate values. For example, jump(50,400) position the turtle at x=50, y=400 on the canvas. 
</p>

<p>
Lines 9-15: we basically create a line with a bend (blip). Lines 9, 11, 13, 15: we use forward() to move the turtle forward by the specified distance in pixels in its current direction; interestingly, we can do mathematical operations, such as 800/3, for the distance, instead of just using a simple integer. Line 10: we use left() to rotate the turtle by the specified degrees to its left; for example, left(60) rotates turtle 60 degrees to its left and the forward() in line 11 moves the turtle forward in that direction. Line 12: we use right() similarly to left(); by rotating the turtle by a sharp 120 degrees, this will create the intended blip. Line 13: the forward() moves the turtle forward, creating the blip. Lines 14 and 15: left() and forward() are used as explained above, generating the final result.
</p>

<p>
Line 19: show() displays the final result. 
</p>
	<figure>
          <img
            src="Lab Module 2 Image 2.3 Result.png"
            alt="Original Result of Koch Curve (Order 1)"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Original Result of Koch Curve (Order 1)
          </figcaption>
        </figure>

         <p>
	Figure 5 shows the original result of the Koch Curve (Order 1). 
	 </p>      


	<figure>
          <img
            src="Lab Module 2 Image 2.4 Code.png"
            alt="Original Code of Koch Curve (Order 2)"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Code of Koch Curve (Order 2)
          </figcaption>
        </figure>

         <p>
	Figure 6 is the original code of Koch Curve (Order 2).
	 </p>      	      

<p>
Line 2: we define a function called blip_line with two parameters—length and order. Length represents the function’s line length; order represents the associated drawn line’s complexity.
</p>

<p>
Lines 3-4: begins an if statement (conditional statement) with the condition that when order == 0 is met, the turtle will move forward by its given length. Note that == is the comparison operator. In other words, if order is 0, then turtle simply draws a straight line of the given length in line 4.
</p>

<p>
Lines 5-12: provided that all conditions given for the if statement are not met, the code for the written else portion, first designated in line 5, will be executed instead. So here, if the order is not 0, the else code will initiate. Line 6 is function blip_line() defined in line 2, with parameters specified under specific conditions; length is divided by 3, and order is reduced by -1—this moves the turtle forward and creates the fractal pattern. Line 7 uses left(60) to rotate turtle left by 60 degrees, and thus creates the angle. Line 8 repeats the aforementioned blip_line() function as explained, moving the turtle under the given conditions. Line 9 then uses right(120) to rotate turtle to right by 120 degrees. Line 10 then sends turtle forward similarly to lines 6 and 8. Line 11 works like line 7. Line 12 uses the blip_line function to finalize the turtle’s movement.
</p>

<p>
Line 15: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas.
</p>

<p>
Lines 17-26: we draw blip lines of different orders. 
</p>

<p>
Line 18: jump() is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. 
</p>
	      
<p>
Line 19: face() is a function that points the turtle in a specific direction; for example, face(90) points the turtle North.
</p>
	      
<p>
Line 20: color() is the function that specifies the line color; for example, color(‘red’) specifies line color to be red. 
</p>

<p>
Line 21: blip-line() is the defined function, as explained previously; blip_line(800,1) sets initial line length to be 800, while 1 is the line’s complexity, i.e., the order of the fractal. This is the red line shown in the resulting image. 
</p>

<p>
Lines 23-26 work similarly, but with the following changes: our initial turtle starting position is slightly different in the y-coordinate, now at jump(50,350) instead of jump(50,400); our face(), or direction, is still North; line color is now blue; and our blip_line function has the same line length but now operates with order 2, yielding a more complex pattern. This is the blue line, which has a middle shape reminiscent to a star, in the resulting image. Higher orders will consequently break our generated line into smaller and smaller segments, yielding smaller blips at angles to manifest a more intricate pattern. 
</p>

<p>
Line 28: show() displays the final result. 
</p>

	      
	<figure>
          <img
            src="Lab Module 2 Image 2.4 Result.png"
            alt="Original Result of Koch Curve (Order 2)"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Result of Koch Curve (Order 2)
          </figcaption>
        </figure>

         <p>
	Figure 7 shows the original result of the Koch Curve (Order 2).
	 </p> 	   

	<figure>
          <img
            src="Lab Module 2 Image 2.5 Code.png"
            alt="Original Code of Koch Curve (Order 3)"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Code of Koch Curve (Order 3)
          </figcaption>
        </figure>

         <p>
	Figure 8 shows the original code of the Koch Curve (Order 3)
	 </p> 

<p>
Line 1: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas.
</p>

<p>
Line 2: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position.
</p>

<p>
Line 4:  jump() is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. Here, we start at jump(50,300).
</p>

<p>
Line 5: face() is a function that points the turtle in a specific direction; here, face(90) points the turtle North.
</p>

<p>
Line 6: color() is the function that specifies the line color; here, color(‘green’) specifies line color to be green.
</p>

<p>
Line 7: blip-line() is the defined function, as explained previously; blip_line(800,3) sets initial line length to be 800, while 3 is the line’s complexity, i.e., the order of the fractal. This is the green line shown in the resulting image. It is noticeably more complex than the patterns, in red and blue, generated by the previous program.
</p>

<p>
Line 8: show() displays the final result.
</p>

	<figure>
          <img
            src="Lab Module 2 Image 2.5 Result.png"
            alt="Original Result of Koch Curve (Order 3)"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Result of Koch Curve (Order 3)
          </figcaption>
        </figure>
	
	<p>
	Figure 9 shows original result of the Koch Curve (Order 3). 
	</p>	      
	<figure>
          <img
            src="Lab Module 2 Image 2.6 Code.png"
            alt="Original Code of Koch Snowflake"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Code of Koch Snowflake
          </figcaption>
        </figure>	      
      
	<p>
	Figure 10 shows the original code of the Koch Snowflake.
	</p>
<p>
Line 1: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas.
</p>

<p>
Line 2: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position.
</p>   

<p>
Line 5: we define a function called blip_line with two parameters—length and order. Length represents the function’s line length; order represents the associated drawn line’s complexity.
</p>	

<p>
Lines 6-7: begins an if statement (conditional statement) with the condition that when order == 0 is met, the turtle will move forward by its given length. Note that == is the comparison operator. In other words, if order is 0, then turtle simply draws a straight line of the given length in line 7. 
</p>

<p>
Lines 8-15: provided that all conditions given for the if statement are not met, the code for the written else portion, first designated in line 8, will be executed instead. So here, if the order is not 0, the else code will initiate. Line 9 is function blip_line() defined in line 5, with parameters specified under specific conditions; length is divided by 3, and order is reduced by -1—this moves the turtle forward and creates the fractal pattern. Line 10 uses left(60) to rotate turtle left by 60 degrees, and thus creates the angle. Line 11 repeats the aforementioned blip_line() function as explained, moving the turtle under the given conditions. Line 12 then uses right(120) to rotate turtle to right by 120 degrees. Line 13 then sends turtle forward. Line 13 works like line 10. Line 15 uses the blip_line function to finalize the turtle’s movement.
</p>

<p>
Lines 18-21: here we draw the Koch Snowflake. 
</p>   

<p>
Line 18: we define a function called koch_snowflake with two parameters, length and order. Length will be the overall size of the generated Koch Snowflake while order determines the overall level of detail; a more complicated snowflake will generate with higher orders.
</p>	

<p>
Line 19: we start a for loop in given range. This means the loop will run a set number of times, as specified in the range. Here, since we have for _ in range(3), the loop will run 3 times total before stopping. 
</p>

<p>
Line 20: we already defined the blip_line function in line 5. We can now use this blip_line function to draw a single element of the snowflake in this for loop.
</p>

<p>
Line 21: recall that right() simply turns the turtle to the right by the set degrees. Here, we have right(120); this means the turtle will turn right by 120 degrees. This turn is performed after each segment of the Koch Snowflake is drawn in the for loop. If the current range in the for loop is less than 3, the snowflake will not connect. 
</p>   

<p>
Line 24: jump() is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. Here, we start at jump(250,300).
</p>	

<p>
Line 25: face() is a function that points the turtle in a specific direction; here, face(0) points the turtle East.
</p>

<p>
Line 26: color() is the function that specifies the line color; here, color(‘blue’) specifies line color to be blue.
</p>

<p>
Line 29: length is the variable that sets the line length. Overall, this will be the size of the generated snowflake. Smaller integers will yield a smaller snowflake, while larger integers will yield a larger snowflake. Note that the turtle’s drawing canvas will need to be altered for large snowflakes.
</p>

<p>
Line 30: order is the variable used to assign different complexity values to the snowflake; higher order yield greater complexity and thus a more intricate pattern.
</p>	      

<p>
Line 31: the function koch_snowflake is called to finally draw the snowflake with its associated two parameters, length and order, values assigned in lines 29-30. 
</p>

<p>
Line 33: show() displays the final result.
</p>	
	      
	<figure>
          <img
            src="Lab Module 2 Image 2.6 Result.png"
            alt="Original Result of Koch Snowflake"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Result of Koch Snowflake
          </figcaption>
        </figure>	      
      
	<p>
	Figure 11 shows the original code of the Koch Snowflake.
	</p>	      
	 <figure>
          <img
            src="Lab Module 2 Image 2.7 Dragon Curve Code.png"
            alt="Original Code of Dragon Curve"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Code of Dragon Curve
          </figcaption>
        </figure>	      
      
	<p>
	Figure 12 shows the original code of the Dragon Curve.
	</p>

<figure>
          <img
            src="Lab Module 2 Image 2.7 Dragon Curve Result.png"
            alt="Original Result of Dragon Curve"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Original Result of Dragon Curve
          </figcaption>
        </figure>	      
      
	<p>
	Figure 13 shows the original result of the Dragon Curve.
	</p>
	      
      </section>

	
	    

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          We successfully showcased an introduction to basic Python coding and turtle graphics. Additionally, we have shown modifications to basic Python coding and 
	  turtle graphics in order to demonstrate understanding of the various code functions involved. This report attempts to convey an introduction to the overall power of Python programming, 
	  such as in numerical calculations and image development. This report also demonstrates learning HTML for GitHub for website production.  
	  This concludes my Fractal Geometry Lab Report on the Introduction to Turtle Graphics.  
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
