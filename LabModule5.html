<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report: Infinite Dust</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Module 5 Infinite Dust</h1>
    <p class="author">
      [Leigh Brawner] <br />
      [March 18th, 2025]
    </p>
  </header>
  



  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
        This module concentrates on what is called the Cantor Set, which is also known as the Cantor comb or no middle third set (Wolfram). 
	The Cantor Set was originally founded by Irish mathematician, Henry John Stephen Smith, in 1874, but received
	its notoriety due to the more famous German mathematician, Georg Cantor (Set, Smith). Georg Cantor's 10-year work from
	1874 to 1884 is widely considered to be the origin of modern set theory (Cantor). In addition to becoming the father of set theory, 
	Georg Cantor helped lay the foundation of modern point-set topology (Set). Module 5 focuses on what is referred to as the Cantor Ternary Set. 
	Fundamentally, the Cantor Ternary Set is formulated by trisecting a line segment and removing its middle third, thus creating two shorter line segments (Set). 
	This process can infinitely repeat, hence its focus on recursion for its formation in Python coding. 
	Interestingly, the Cantor Ternary Set's complement is referred to as a fractal string, which we explore further in the next sections (Set).
	</p>

        <figure>
          <img
            src="Cantor and Smith.png"
            alt="Cantor Set Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Georg Cantor and Henry John Stephen Smith
          </figcaption>
        </figure>	      
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Cantor Set</h2>
        <p>
          Below is the Colab section showcasing the original Cantor Set.
        </p>

        <figure>
          <img
            src="Cantor Set Code.png"
            alt="Cantor Set Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Cantor Set Code
          </figcaption>
        </figure>

	<p> Cantor Set Code</p>
	<p> Line 1: this line is polite explanation of the code's intent in lines 2-3. We will be defining libraries for our implementation of math and plotting purposes. </p>
	<p> Line 2: this line imports the numpy library, which is essential for numerical computations in Python. It's conventionally imported as np for brevity. numpy provides tools for working with arrays and matrices.</p>
	<p> Line 3: this line imports the pyplot module from the matplotlib library. matplotlib is a popular library for creating visualizations in Python. pyplot is commonly imported as plt and provides functions for creating various types of plots. I've used matlab before, but not much; I've used Maple much more. </p>
	<p> Line 5: this line is polite description of the code's intent in lines 6-11. Overall this section of code (lines 6-11) defines variables that control the full appearance and structure of the Cantor Set. </p>
	<p> Line 6: this line sets the starting horizontal (x-coordinate) position of the first bar. </p>
	<p> Line 7: this line sets the ending horizontal (x-coordinate) position of the first bar. </p>
	<p> Line 8: this line sets the initial vertical (y-coordinate) position of the first bar.</p>
	<p> Line 9: this line determines the height of each bar in the set. </p>
	<p> Line 10: this line controls the vertical distance (distance downwards) between levels of the Cantor Set. </p>
	<p> Line 11: this line specifies the number of recursive levels to generate, influencing the overall complexity of the generated fractal. </p>
	<p> Line 13: this is polite description of the intent of the code in lines 14-16. We will be defining a 4-parameter function called cantor_set, making use of 4 previously defined variables: x_start ; x_end ; y_position ; and depth .  </p>
	<p> Line 14: this line actually defines our 4-parameter function called cantor_set, and is where we make use of our aforementioned 4 defined variables: x_start ; x_end ; y_position ; and depth . </p>
	<p> Lines 15-16: these two lines define our conditional If statement. This is the base case for the recursion. If depth reaches 0, it means we've reached the desired level of detail, and the function returns an empty list, stopping further recursion. 
	The function calculates the coordinates for the left and right segments of the Cantor Set at the current level. 
	It then makes recursive calls to itself to generate segments for the next levels down, adjusting the y_position and depth.
	Finally, it combines the segments from the current level with the results of the recursive calls, creating a complete set of coordinates for the Cantor Set. <p>
	<p> Line 18: this line is polite description of the intent of the code in lines 19-20. Specifically, this will be for the left and right segments for the current bar.
	Basically, this section of the code will be the core of how the Cantor Set pattern is generated. It uses recursion. </p>
	<p> Line 19: this line defines the left segments of the Cantor Set bar for the current level. left_segment stores the coordinates for the left segment of the bar (the first third). 
	The variables x_start, x_end, y_position, hold the starting x-coordinate, ending x-coordinate, and y-coordinate (vertical position) of the current bar, as described above. 
	(x_end - x_start) / 3 will essentially calculate the length of the bar and divides it by 3. This is because the Cantor Set is constructed by repeatedly removing the middle third of each segment.
	Note that spacing is the space between bars (distance downwards). </p>	
	<p> Line 20: this line defines the right segments of the Cantor Set bar for the current level. right_segment stores the coordinates for the righ segment of the bar (the last third).
	The variables x_start, x_end, y_position, hold the starting x-coordinate, ending x-coordinate, and y-coordinate (vertical position) of the current bar, as described previously.
	(x_end -x_start) / 3 will essentially calculate the length of the bar and divide it by 3. This is because the Cantor Set is constructed by repeatedly removing the middle third of each segment. 
	Note that spacing is the space between bars (distance downwards). </p>
	<p> Line 22: this line is polite description of the intent of the code in lines 23-24. Essentially, the cantor_set function calls itself, which is the step recursion. It creates the classic Cantor Set pattern for the left and right segments defined, then goes one level further. </p>
	<p> Lines 23-24: these lines work similary to lines 19-20, but recursively generate segments for the next levels.
	Two major differences are as follows: the y_position - spacing moves the next level down vertically; the depth - 1 reduces the overall depth counter, ensuring the recursion eventually stops. </p>
	<p> Line 26: this line is polite description of the code intent for line 27. Line 27 is an important line, as it is essentially the core of the Cantor Set function.  </p>
	<p> Line 27: this line uses return, which indicates that the function is going to send a value back to where it was called from. In this case, it's returning a list of segments that make up the Cantor Set at the current level of recursion.
		Basically, the function combines the segments it calculated for the current level (left_segment, right_segment) with the segments generated by the recursive calls (left_recursive, right_recursive).
		Therefore, this creates a complete list of segments for the current depth of the Cantor Set pattern and returns it. </p>
	<p> Line 29: this line is polite description of the intent of the code in line 30. Essentially, we are generating Cantor Set segments data and converting to array for easy plotting in Python. </p>
	<p> Line 30: in this line, we have aready defined how 4-parameters work for the function, cantor_set. Recall that these 4-parameters are: x_start ; x_end ; y_position ; depth . 
		np.array(...): here, the result from cantor_set (a list of segments) is passed to the function,  np.array . This function, which comes from the numpy library (imported as np), 
		converts the list into a NumPy array. NumPy arrays are efficient data structures for numerical computations and are often easier to work with for plotting and other mathematical operations in Python. 
		Ultimately, this resulting NumPy array is assigned to the variable, segments. This variable now holds the data representing the Cantor Set, which will be used in the subsequent code to create the visualization. </p>
	<p> Line 32: this line is polite description of the intent of the code in line 33. All we're doing here is plotting/drawing the Cantor Set. </p>
	<p> Line 33: plt.figure(figsize=(25, 25)) in this line creates a new figure (a blank canvas) for the plot using the matplotlib.pyplot module (imported as plt). 
		  The function figure() creates the figure object. figsize=(25, 25)  specifies the dimensions of the figure in inches. 
		  For our purposes, the resulting figure will be 25 inches wide and 25 inches tall, providing a large area for the visualization of the Cantor Set.</p>
	<p> Line 35: this line is polite description of the intent of the code in lines 36-37. Essentially, we're drawing each segment as a black bar. 
		This code loops through a set of coordinates and, for each set, draws a black rectangle defined by the coordinates, effectively visualizing the Cantor Set as a series of black bars.</p>
	<p> Line 36: this line uses a for loop that iterates through each element (segment) within the segments variable (which should contain the coordinates for each segment of the Cantor set). 
		In each iteration, the loop extracts the: starting x-coordinate (x_start); ending x-coordinate (x_end); and y-coordinate (vertical y), in order to assigns them to the corresponding variables.
		</p>
	<p> Line 37: this line is the core of the drawing process. It uses the fill_between() function from matplotlib.pyplot to create a filled rectangle (representing a segment of the Cantor Set).
		We have multiple arguments for fill_between(). 
		[x_start, x_end]: Specifies the horizontal range (x-coordinates) of the rectangle.
		[y] * 2: Defines the upper y-coordinate of the rectangle. [y] * 2 creates a list [y, y] because fill_between expects a list of y-values for the upper bound, even though it's constant in this case.
		[y - bar_height] * 2: Defines the lower y-coordinate of the rectangle (bar_height pixels below the y). Similar to the previous argument, it's duplicated to match the expected input format.
		color="black": Sets the fill color of the rectangle to black. We could easily modify this to change to another color, like blue. </p>
	<p> Line 39: this line is polite description of the code in lines 40-41. We're basically just hiding the plot axes for a cleaner appearance (we don't want to detract from the fractal effect of the Cantor Set with unnecessary lines). </p>
	<p> Line 40: this line uses the matplotlib.pyplot module (imported as plt) to control the appearance of the plot. plt.axis('off'): This function call is used to hide the axes of the plot. 
		The axes include the x-axis and y-axis lines, ticks, and labels. By setting the axis to 'off', we remove these elements, leaving only the visualized data. 
		This is done for a cleaner, more focused visualization, especially when the context of the axes isn't crucial for understanding the data. </p>
	<p> Line 41: this line uses plt.show(). This is a crucial function in matplotlib and works similarly to show() in Python's turtle graphics. 
		It displays the plot that has been created up to this point in the code. Without this line, the plot would be generated but not shown on your screen. </p>		      
	<figure>
          <img
            src="Cantor Set Image.png"
            alt="Cantor Set Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Image
	  </figcaption>
        </figure>





	      


<figure>
          <img
            src="Lab Module 3 Sierpinski Carpet Result.png"
            alt="Lab Module 3 Sierpinski Carpet Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Carpet
          </figcaption>
        </figure>      

	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.6 Code.png"
            alt="Lab Module 3 Image 3.6 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Cellular Automata Section
          </figcaption>
        </figure>	      
<p> Line 1: This line imports the numpy library, which is a fundamental package for numerical computation in Python. It's aliased as np for convenience, so you can refer to numpy functions using np prefix (e.g., np.array). numpy provides support for arrays, matrices, and various mathematical functions.</p>
<p> Line 2: This line imports the matplotlib.pyplot module, which provides a collection of functions that make matplotlib work like MATLAB. It's aliased as plt. This is used for creating visualizations like plots, charts, and in this case, images.</p>	   
<p> Line 4: This line defines a function named plot that takes one argument, x. This x is expected to be a 2D array (like a matrix). </p>
<p> Line 5: This line creates a new figure and a set of subplots. The fig variable holds the figure object, and the ax variable holds the axes object. </p>
<p> Line 6: This is the core of the plotting. The imshow function from the ax object takes the input array x and displays it as an image. The cmap='gray' argument sets the color map to grayscale, meaning the values in the array will be represented using shades of gray. </p>
<p> Line 7: This line turns off the axes of the plot, so the tick marks and labels are not visible. </p>
<p> Line 8: This line sets the size of the generated figure to 10x10 inches. </p>
<p> Line 9: This line displays the created plot. </p>
	      
	      
		
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          We successfully created a forest of unique fractal trees using turtle graphics by creating 2-parameter functions and 3-parameter functions. We then modified these functions to showcase how implementing recursion steps in Python can generate fractal trees.
	  This also demonstrates how technological advances enable us to formulate complex patterns for scientific analysis or teaching purposes, enabling a deeper understanding of complicated biological structures overall. </p>

	  <h2>Works Cited </h2>    


Barile, Margherita and Weisstein, Eric W. "Cantor Set." From MathWorld—A Wolfram Web Resource. https://mathworld.wolfram.com/CantorSet.html 

“Cantor set.” Wikipedia, Wikimedia Foundation, 2 March 2025, https://en.wikipedia.org/wiki/Cantor_set 

“Georg Cantor.” Wikipedia, Wikimedia Foundation, 16 March 2025, https://en.wikipedia.org/wiki/Georg_Cantor

“Henry John Stephen Smith.” Wikipedia, Wikimedia Foundation, 5 October 2024, https://en.wikipedia.org/wiki/Henry_John_Stephen_Smith 
	      
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
