<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report: Three Sides to the Triangle </title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Three Sides to the Triangle </h1>
    <p class="author">
      [Leigh Brawner] <br />
      [February 25th, 2025]
    </p>
  </header>
  



  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This Fractal Geometry Lab Report focuses on the triangle and its implementation/association in constructing Sierpinski Triangles using turtle graphics in Python. 
        </p>
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>

        <figure>
          <img
            src="Lab Module 3 Image 3.1.png"
            alt="Library Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Library Code
          </figcaption>
        </figure>

	<p>
	Figure 1 shows the code for installing the library associated to this module. This installs the turtle library as stated so that we can implement commands specific to turtle.
</p>
<p>Line 1: we use the !wget command, which is a command-line tool for downloading files from the internet. In this context, it's used within the Jupyter Notebook to download a Python script called turtle_setup.py. -O turtle_setup.py specifies that the downloaded file should be saved with the name turtle_setup.py. 'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py' is the URL from where the turtle_setup.py script is downloaded. It's hosted on GitHub.</p>      
<p>Line 2: this implements from and import so that we can use the script downloaded from turtle_setup.py. Note that * means ‘all’, so that all functions and definitions from said script will be available for use.</p>
	 <figure>
          <img
            src="Lab Module 3 Image 3.2 Code.png"
            alt="Lab Module 3 Image 3.2 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Equilateral Triangle Function Code
          </figcaption>
        </figure>      
    <p>
	This concise code formulates an equilateral triangle using a for loop; however, the turtle will need additional code to move, which will be discussed in the next figure. 
	Line 2: we use def to define a function called draw_triangle that has one parameter, called length. Length will be the overall size of the generated triangle. 
	Line 3: we start a for loop in given range. This means the loop will run a set number of times, as specified in the range. Here, since we have for _ in range(3): , the loop will run 3 times total before stopping.  
    	Line 4: the function forward() is called to move the turtle by the specified length; specifying length will occur in the next figure, not here.
	Line 5: the function left() is used to swivel the turtle by the given degrees after the turtle completes its specified length in line 4; since we have left(120), our turtle will rotate left by a 120 angle after concluding said distance. 
    </p>  
	 
	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.3 Code.png"
            alt="Lab Module 3 Image 3.3 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Drawing Equilateral Triangle Code
          </figcaption>
        </figure>	      
<p>     Line 1: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas. </p>
<p>     Line 2: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position. </p>
<p>     Lines 5-8: this concise code formulates an equilateral triangle using a for loop, and was explained in-depth in the previous section. </p>	
<p>     Line 10: we describe the intention of the code's operation in lines 11-15. </p>
<p>     Line 11: jump(x,y) is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. Here, we start at jump(300,500). </p>
<p>     Line 12: face() is a function that points the turtle in a specific direction; here, face(90) points the turtle North. </p>
<p>     Line 13: color() is the function that specifies the line color; here, color(‘green’) specifies line color to be green. </p>
<p>     Line 14: length() is the variable that sets the line length. Overall, this will be the size of the generated equilateral triangle (smaller numbers will yield smaller triangles, whereas larger numbers will yield larger triangles). </p>
<p>     Line 15: the function draw_triangle is called to finally draw the equilateral triangle with its associated parameter, length, a value assigned in line 14. </p>
<p>     Line 17: show() displays the final result. </p>
	      
	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.3 Result.png"
            alt="Lab Module 3 Image 3.3 Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Drawing Equilateral Triangle Result
          </figcaption>
        </figure>
<p> This is the result of the turtle drawing our equilateral triangle function. </p>
	     
	      <figure>
          <img
            src="Lab Module 3 Image 3.4 Code.png"
            alt="Lab Module 3 Image 3.4 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Triangle Function Code
          </figcaption>
        </figure>

<p> Line 1: uses # to describe the function of the following code; in this case, we will be defining a Sierpinski Triangle Function using a recursive method. </p>
<p> Line 2: we use def to define a function called sierpinski_triangle with two parameters, length and order. Length represents the function’s line length; in this case, the triangle's length. Order determines the associated drawn line’s complexity, i.e., the overall complexity of the Sierpinski Triangle. </p>   
<p> Lines 3-4: begins an if statement (conditional statement) with the base case condition that when order == 0 is met, the turtle will move forward by its given length. Note that == is the comparison operator. In other words, if order is 0, then turtle simply draws the equilateral triangle function defined earlier (with accompanied given length, of course). </p>	      
<p> Line 5: this begins the else component of our if statement, which occurs when the given base case is not met, i.e., when order is not 0. </p>	      
<p> Line 6: sierpinski triangles fundamentally contain smaller triangles within triangles, namely 3 per triangle. This line of code initiates the first smaller triangle within the defined sierpinski function, sierpinski_triangle(length / 2, order -1). Here, current length is reduced by half using the mathematical division operator, and order is reduced by 1. </p>	
<p> Line 7: the function forward() moves the turtle forward, in this case by length / 2. </p>
<p> Line 8: draws the second smaller sierpinski triangle, similarly to line 6. </p>
<p> Line 9: the function backward() moves the turtle backward; in this case, we move backward by length / 2, thus returning the turtle to the initial position. </p>
<p> Line 10: the left() function rotates the turtle left by the given degrees. In this case, left(60) rotates the turtle 60 degrees to the left. No movement is made, only rotation.  </p>
<p> Line 11: the turtle now moves forward by a distance of length / 2, which occurs after the rotation in line 10. </p>
<p> Line 12: the function right() rotates the turtle by a set number of degrees to the right. After completing the set distance in line 12, the turtle rotates right by 60 degrees. </p>
<p> Line 13: draws our third smaller triangle, similarly to line 6; thus, we dinstinguish the fractal as a sierpinski triangle. </p>
<p> Line 14: the left() function rotates the turtle left by the given degrees. In this case, left(60) rotates the turtle 60 degrees to the left. No movement is made, only rotation. </p>
<p> Line 15: the function backward() moves the turtle backward; in this case, we move backward by length / 2, connecting the figure. </p>
<p> Line 16:the function right() rotates the turtle by a set number of degrees to the right; this rotation finalizes the specified sierpinski triangle recursion. </p>
	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.5 Code.png"
            alt="Lab Module 3 Image 3.5 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Drawing Sierpinski Triangle Function Code
          </figcaption>
        </figure>

<p> Line 1: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas. </p>	      
<p> Line 2: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position. </p>	
<p> Line 5: jump(x,y) is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. Here, we start at jump(300,500). </p>
<p> Line 6: face() is a function that points the turtle in a specific direction; here, face(90) points the turtle North. </p>
<p> Line 7: color() is the function that specifies the line color; here, color(‘green’) specifies line color to be green. </p>
<p> Line 10: length is the variable that sets the line length. This will be the overall size of the generated sierpinski triangle (smaller numbers will yield smaller sierpinski triangles, whereas larger numbers will yield larger sierpinski triangles). Here, our length is 400. </p>
<p> Line 11: order is the variable used to assign different complexity values to the sierpinski triangle; higher order yields greater complexity and thus a more intricate pattern of the fractal overall. Here, the order is 4. </p>
<p> Line 12: the recursive function sierpinski_triangle is called (from the previous section of code) to finally draw the sierpinski triangle with its associated two parameters, length and order, values assigned in lines 10-11. </p>
<p> Line 14: show() displays the final result. </p>
	      	      

 <figure>
          <img
            src="Lab Module 3 Image 3.5 Result.png"
            alt="Lab Module 3 Image 3.5 Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Triangle Fractal
          </figcaption>
        </figure>      

<figure>
          <img
            src="Lab Module 3 Sierpinski Carpet Code.png"
            alt="Lab Module 3 Sierpinski Carpet Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Carpet Code
          </figcaption>
        </figure>      
<p> We've essentially modified both the previously analyzed triangle function code and Sierpinski triangle code in order to create another fractal called the Sierpinski Carpet. The Sierpinski Carpet is somewhat similar to the Sierpinski Triangle, but is instead based off a square; consequently, we subdivide the square into nine smaller squares, as opposed to the subdivision of a triangle into three smaller triangles. Let's begin! </p>
<p> Line 1: we use # to begin a brief description of our following code for the Sierpinski Carpet; particularly, a Sierpinski Carpet of order 4. </p>
<p> Line 2: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas. </p>
<p> Line 3: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position. </p>
<p> Lines 5-8: this is analogous to the code used in the equilateral triangle creation. </p>
<p> Line 5: we use def to define a function called draw_square that has one parameter, called length. Length will be the overall size of the generated square. </p>
<p> Line 6: we start a for loop in given range. This means the loop will run a set number of times, as specified in the range. Here, since we have for _ in range(4): , the loop will run 4 times total before stopping (which is logical, since a square has four equal sides). </p> 
<p> Line 7: the function forward() is called to move the turtle by the specified length; specifying length will occur in line 26. </p>	   
<p> Line 8: the function left() is used to swivel the turtle by the given degrees after the turtle completes its specified length; since we have left(90), our turtle will rotate left by a 90 angle after concluding said distance. This is logical, since a square is formed of 4 angles, each of which is 90 degrees. </p>
<p> Lines 11- 21: this block of code is analogous to the code implemented in formulating the Sierpinski Triangle Function. </p>
<p> Line 11: we use def to define a function called sierpinski_carpet with two parameters, length and order. Length represents the function’s line length; in this case, the square's length. Order determines the associated drawn line’s complexity, i.e., the overall complexity of the Sierpinski Carpet. </p>
<p> Lines 12-13: begins an if statement (conditional statement) with the base case condition that when order == 0 is met, the turtle will move forward by its given length. Note that == is the comparison operator. In other words, if order is 0, then turtle simply draws the square function defined earlier (with accompanied given length, of course).</p>
<p> Line 14: this begins the else component of our if statement, which occurs when the given base case is not met, i.e., when order is not 0. </p>
<p> Line 15: starts the for loop in range (4) </p>
<p> Line 16: the Sierpinski Carpet fundamentally contains smaller squares within squares, namely 9 per square. This line of code initiates the first smaller square within the defined sierpinski function, sierpinski_carpet(length / 3, order -1). Here, current length is reduced by one-third using the mathematical division operator, and order is reduced by 1. </p>
<p> Line 17: the function forward() moves the turtle forward, in this case by length / 3. </p>
<p> Line 18: draws the second smaller square, similarly to line 15. </p>
<p> Line 19:  the function forward() moves the turtle forward, in this case by length / 3. </p>
<p> Line 20: the function forward() moves the turtle forward, in this case by length / 3. </p>
<p> Line 21: the left() function rotates the turtle left by the given degrees. In this case, left(90) rotates the turtle 90 degrees to the left (a right angle). No movement is made, only rotation.</p>
<p> Line 23: jump(x,y) is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. Here, we start at jump(300,500). </p>
<p> Line 24: face() is a function that points the turtle in a specific direction; here, face(90) points the turtle North. </p>
<p> Line 25: color() is the function that specifies the line color; here, color(‘aqua’) specifies line color to be aqua (a pretty blue). </p>
<p> Line 26: length is the variable that sets the line length. This will be the overall size of the generated sierpinski carpet (smaller numbers will yield smaller sierpinski carpets, whereas larger numbers will yield larger sierpinski carpets). Here, our length is 400. </p>
<p> Line 27: order is the variable used to assign different complexity values to the sierpinski carpet; higher order yields greater complexity and thus a more intricate pattern of the fractal overall. Here, the order is 4. </p>
<p> Line 28: the recursive function sierpinski_carpet is called to finally draw the sierpinski carpet with its associated two parameters, length and order, variables assigned in lines 26 and 27, respectively. /p>
<p> Line 30: show() displays the final result, i.e., our Sierpinski Carpet. </p>
<figure>
          <img
            src="Lab Module 3 Sierpinski Carpet Result.png"
            alt="Lab Module 3 Sierpinski Carpet Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Carpet
          </figcaption>
        </figure>      

	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.6 Code.png"
            alt="Lab Module 3 Image 3.6 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Cellular Automata Section
          </figcaption>
        </figure>	      
<p> Line 1: This line imports the numpy library, which is a fundamental package for numerical computation in Python. It's aliased as np for convenience, so you can refer to numpy functions using np prefix (e.g., np.array). numpy provides support for arrays, matrices, and various mathematical functions.</p>
<p> Line 2: This line imports the matplotlib.pyplot module, which provides a collection of functions that make matplotlib work like MATLAB. It's aliased as plt. This is used for creating visualizations like plots, charts, and in this case, images.</p>	   
<p> Line 4: This line defines a function named plot that takes one argument, x. This x is expected to be a 2D array (like a matrix). </p>
<p> Line 5: This line creates a new figure and a set of subplots. The fig variable holds the figure object, and the ax variable holds the axes object. </p>
<p> Line 6: This is the core of the plotting. The imshow function from the ax object takes the input array x and displays it as an image. The cmap='gray' argument sets the color map to grayscale, meaning the values in the array will be represented using shades of gray. </p>
<p> Line 7: This line turns off the axes of the plot, so the tick marks and labels are not visible. </p>
<p> Line 8: This line sets the size of the generated figure to 10x10 inches. </p>
<p> Line 9: This line displays the created plot. </p>
	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.7 Code.png"
            alt="Lab Module 3 Image 3.7 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Image 3.7 Code
          </figcaption>
        </figure>
<p> Line 1: This line initializes a 2D array, also known as a matrix, using np.zeros(). np.zeros((100,100)) creates a 100x100 matrix filled with zeros. .astype(int) converts the data type of the elements in the matrix to integers. The resulting matrix is assigned to the variable C. </p>
<p> Line 2: This line modifies the matrix C. It sets the value at the position [0, 50] to 1. Remember that Python uses zero-based indexing, so 0 refers to the first row, and 50 refers to the 51st column. </p>
<p> Line 3:This line calls a previously defined function called plot(), passing the matrix C as an argument. </p>

<p> In summary, this code creates a 100x100 matrix of zeros, sets the element at row 0 and column 50 to 1, and then displays this matrix as a grayscale image, where the single 1 value will be a different color from the zeros. </p>
	      <figure>
          <img
            src="Lab Module 3 Image 3.7 Result.png"
            alt="Lab Module 3 Image 3.7 Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             100 x 100 matrix of zeroes result
          </figcaption>
        </figure>

	      <figure>
          <img
            src="Lab Module 3 Image 3.8 Code.png"
            alt="Lab Module 3 Image 3.8 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Binary in Python
          </figcaption>
        </figure>
<p> Line 1: This line assigns the integer value 90 to the variable num. </p>
<p> Line 2: print(): This is a built-in Python function that displays output to the console.
f'{num:08b}': This is an f-string, a way to embed expressions inside string literals.
num: This inserts the value of the num variable (which is 90).
:08b: This is a format specifier that tells Python how to format the inserted value:
b: This indicates that the value should be formatted as a binary number.
08: This specifies that the binary representation should be padded with leading zeros so that it has a total width of 8 characters. </p>

<p> This code takes decimal number 90, converts it to its binary equivalent, then prints the associated 8-digit binary representation, padding with leading zeros if necessary. </p> 
	      
 	<figure>
          <img
            src="Lab Module 3 Image 3.9 Code.png"
            alt="Lab Module 3 Image 3.9 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Cellular Automaton (1)
          </figcaption>
        </figure>      

<p> Line 1: This line initializes a 3-dimensional numpy array called rule. np.zeros((2,2,2)) creates a 3D array filled with zeros. The dimensions of the array are (2, 2, 2), meaning it can be thought of as a cube with 2 layers, each of which is a 2x2 matrix. In this context, each of these dimensions is representing the three neighbors of a cell.</p>
<p> Lines 3-10: These lines assign specific values (either 0 or 1) to each position in the rule array. Each position in the array represents a different possible configuration of the cell's three neighbors. The indices of the array access the following pattern: rule[NW, N, NE]. In this case:

NW is the state of the cell to the Northwest (or the cell directly to the left in the previous row)
N is the state of the cell to the North (or the cell directly above in the previous row)
NE is the state of the cell to the Northeast (or the cell directly to the right in the previous row)
Let's break down what each assignment represents:

rule[0,0,0] = 0: If the Northwest, North, and Northeast cells are all 0, the cell becomes 0.
rule[0,0,1] = 1: If the Northwest and North cells are 0 and Northeast is 1, the cell becomes 1.
rule[0,1,0] = 0: If the Northwest cell is 0, North is 1, and Northeast is 0, the cell becomes 0.
rule[0,1,1] = 1: If the Northwest cell is 0, North is 1, and Northeast is 1, the cell becomes 1.
rule[1,0,0] = 1: If the Northwest cell is 1, North is 0, and Northeast is 0, the cell becomes 1.
rule[1,0,1] = 0: If the Northwest cell is 1, North is 0, and Northeast is 1, the cell becomes 0.
rule[1,1,0] = 1: If the Northwest cell is 1, North is 1, and Northeast is 0, the cell becomes 1.
rule[1,1,1] = 0: If the Northwest, North, and Northeast cells are all 1, the cell becomes 0. </p>

<p> In summary, this code defines a rule set for a cellular automaton, where a cell's next state depends on the states of its immediate neighbors based on the 3-dimensional rule array. </p>	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.10 Code.png"
            alt="Lab Module 3 Image 3.10 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Cellular Automata Function
          </figcaption>
        </figure>	      

<p> Line 1: This line defines a function named CA that takes one argument, X. It's expected that X is a 2-dimensional NumPy array representing the grid of cells. </p>
<p> Lines 3-4: This is a nested for loop. The outer loop iterates through the rows of the array X, from the second row (index 1) up to the second to last row. Similarly, the inner loop iterates through the columns of the array X, from the second column (index 1) up to the second to last column. This is done so that the code does not access values outside of the array bounds when calculating neighbor values. The comments #row and #col are there to remind the reader of what the loops represent. </p>
<p> Lines 6-8: These lines extract the values of the neighboring cells for the cell at position (i, j). In particular, we are only using the immediate row above cell (i,j) to compute the new state of the cell. - N (North) gets the value of the cell directly above (i, j). - NW (Northwest) gets the value of the cell diagonally above and to the left of (i, j). - NE (Northeast) gets the value of the cell diagonally above and to the right of (i, j). </p>	      
<p> Line 10: This is the core of the CA update rule. It calculates the new state of the cell at position (i, j). The new state is assigned by indexing into the rule array. The rule is a 3D array that determines the new state based on the neighboring states: NW, N, and NE.</p>
<p> Line 12: The function returns the modified array X, which now contains the updated states of the cells after one iteration. </p>

<p> In summary, this CA function implements a one-dimensional cellular automaton where the state of a cell in the next row is determined by the states of its three immediate neighbors (NW, N, and NE) from the previous row according to a predefined rule. The rule is stored in a 3D numpy array called rule. This function does not modify the first or last row and the first and last columns of the array. </p>
	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.11 Code.png"
            alt="Lab Module 3 Image 3.11 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Plotting the Cellular Automaton Function
          </figcaption>
        </figure>
<p> Line 1: The CA function is called with the initial array C. The CA function modifies the array C based on the specified cellular automata rule, and a modified 2D array is returned as output. The resulting 2D array from CA is then passed as the argument to the plot function. The plot function displays the modified array as a grayscale image using matplotlib. </p>
	      
	      <figure>
          <img
            src="Lab Module 3 Image 3.11 Result.png"
            alt="Lab Module 3 Image 3.11 Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Plot of the Cellular Automaton Function
          </figcaption>
        </figure>

	      <figure>
          <img
            src="Lab Module 3 Image 3.12 Code.png"
            alt="Lab Module 3 Image 3.12 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Cellular Automata Function and Execution
          </figcaption>
        </figure>
<p> Line 1: This line defines a function named CA that takes a 2D array, represented by the variable X, as its input. This array will represent the state of the cellular automaton grid. </p>
<p> Line 3: This starts a for loop that iterates through the rows of the array X. X.shape[0] gets the number of rows, and it starts from index 1 and goes up to, but not including, the second to last index. This avoids going out of bounds when accessing neighbors in the next loop. </p>
<p> Line 4: This is a nested for loop that iterates through the columns of the array X, skipping the first and last columns, similar to the row loop. X.shape[1] gets the number of columns.</p>
<p> Line 6: X[i-1,j-1]: accesses the top-left neighbor of the current cell.
X[i-1,j]: accesses the top-center neighbor of the current cell.
X[i-1,j+1]: accesses the top-right neighbor of the current cell.
4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]: This combines the values of the three neighbors by applying weights. The neighbors can be either 0 or 1. This creates an integer value between 0 and 7.
2**(4*X[i-1,j-1] + 2*X[i-1,j] + X[i-1,j+1]): This raises 2 to the power of the weighted neighbor sum, creating a unique value based on the neighborhood configuration.
rule / ... This divides the global variable rule (explained below) by the previously generated number.
(... ) % 2: The result of the division is then taken modulo 2, to ensure the cell is only ever 0 or 1. This calculates the new state (0 or 1) for the current cell at X[i, j] based on the state of its neighbors in the previous row. </p>
<p> Line 8: The function returns the updated cellular automaton grid.</p>
<p> Line 10:This sets a global variable named rule to 90. This variable is used in the CA function to determine the update rule applied to each cell. It’s important to note that in this specific implementation the rule number is NOT used as a binary value to create a lookup table. </p>
<p> Line 12: This line calls the CA function with the initial state of the cellular automaton grid, stored in the variable C, and then passes the returned updated grid to a plot function that displays the output using matplotlib. The updated C variable is not stored after running the function. </p>	      
 <figure>
          <img
            src="Lab Module 3 Image 3.12 Result.png"
            alt="Lab Module 3 Image 3.12 Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Cellular Automata Function and Execution Resulting Image
          </figcaption>
        </figure>      
      
	      <figure>
          <img
            src="Lab Module 3 Image 3.13 Code.png"
            alt="Lab Module 3 Image 3.13 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Final for Loop
          </figcaption>
        </figure>	      
<p> Line 1: This line initiates a for loop. The loop variable is named rule. In each iteration, rule takes on the next value from the list [30, 62, 90, 110, 126]. So, the code inside the loop will be executed five times, with rule being 30, 62, 90, 110, and 126 respectively in each of the 5 loops.</p>
<p> Line 2: This line is the body of the loop. It calls the function CA() with the variable C and passes the result to the function plot(). The CA() function, as defined in the earlier code, appears to be a function that applies a cellular automaton rule to a grid, and plot() displays that grid. The value of rule that was set in the for loop is used in this CA() function. </p>
	      <figure>
          <img
            src="Lab Module 3 Image 3.13a Result.png"
            alt="Lab Module 3 Image 3.13a Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Image 3.13a Result
          </figcaption>
        </figure>

	      <figure>
          <img
            src="Lab Module 3 Image 3.13b Result.png"
            alt="Lab Module 3 Image 3.13b Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Image 3.13b Result
          </figcaption>
        </figure>

	      <figure>
          <img
            src="Lab Module 3 Image 3.13c Result.png"
            alt="Lab Module 3 Image 3.13c Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
              Image 3.13c Result
          </figcaption>
        </figure>

	      <figure>
          <img
            src="Lab Module 3 Image 3.13d Result.png"
            alt="Lab Module 3 Image 3.13d Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Image 3.13d Result
          </figcaption>
        </figure>

	      <figure>
          <img
            src="Lab Module 3 Image 3.13e Result.png"
            alt="Lab Module 3 Image 3.13e Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
              Image 3.13e Result
          </figcaption>
        </figure>	      
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>


	      
