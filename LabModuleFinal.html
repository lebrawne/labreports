<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Final</h1>
    <p class="author">
      [Leigh Brawner] <br />
      [April 24th, 2025]
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
		This is my Final for Fractal Geometry.
        </p>

	      
<h2>Part 1: Chaos Game </h2>
	      
	      
	      <figure>
          <img
            src="Chaos Game Triangle Code.png"
            alt="Chaos Game Triangle Code"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Chaos Game Triangle Code
          </figcaption>
        </figure>

<p>Line 1: This line imports the pyplot module from the matplotlib library and assigns it the alias plt. This module is commonly used for creating visualizations in Python, such as plotting graphs.</p>
<p>Line 2: This imports the random and randint functions from the random module. These functions are used for generating random numbers. random() generates a random float between 0 and 1, while randint(a, b) generates a random integer between a and b (inclusive).</p>
<p>Line 3: This imports the numpy library and assigns it the alias np. numpy is a powerful library for numerical computing in Python, providing tools for working with arrays and matrices.</p>
<p>Line 5: This line defines a function called midpoint that takes two arguments, P and Q. These arguments are expected to be tuples or lists representing points in 2D space (e.g., (x, y)).</p>
<p>Line 6: This line calculates the midpoint between points P and Q using the midpoint formula: ((x1 + x2)/2, (y1 + y2)/2). The result, a new point representing the midpoint, is then returned by the function.</p>
<p>Line 8: This line defines a list called vertices that stores the coordinates of the three vertices of an equilateral triangle. np.sqrt(3) is used to calculate the y-coordinate of the second vertex, ensuring the triangle is equilateral.</p>
<p>Line 9: This line sets the number of iterations for the Chaos Game to 50,000. In other words, the game will be played 50,000 times.</p>
<p>Line 10: This line creates two lists, x and y, to store the x and y coordinates of the points generated during the Chaos Game. Both lists are initialized with 50,000 zeros.</p>
<p>Line 11: This line sets the initial point for the Chaos Game to a random location within the unit square (0 to 1 for both x and y coordinates).</p>
<p>Line 13: This initiates a loop that will run iterates (50,000) times.</p>
<p>Line 15: Inside the loop, this line randomly selects one of the three vertices of the triangle using randint(0, 2). The result, k, will be 0, 1, or 2, corresponding to the index of the chosen vertex in the vertices list.</p>
<p>Line 17: This line calculates the midpoint between the randomly selected vertex (vertices[k]) and the previous point ((x[i-1], y[i-1])) using the midpoint function. The resulting coordinates are then stored in the x and y lists.</p>
<p>Line 19: This line creates a new figure for the plot with a size of 8 inches by 8 inches.</p>
<p>Line 20: This line creates a scatter plot using the points generated during the Chaos Game. The x and y lists provide the coordinates, color = 'b' sets the color of the points to blue, and s=0.1 sets the size of the points to 0.1.</p>
<p>Line 21: This line sets the title of the plot.</p>
<p>Line 22: This line ensures that the x and y axes have equal scaling, which is important for visualizing the equilateral triangle correctly.</p>
<p>Line 23: This line displays the plot.</p>
	      
	      	<figure>
          <img
            src="Chaos Game Triangle.png"
            alt="Chaos Game Triangle"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Chaos Game Triangle
          </figcaption>
        </figure>	      



	      
	      	    <figure>
          <img
            src="Barnsley Fern Code 1.1.png"
            alt="Barnsley Fern Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>
    	    <figure>
          <img
            src="Barnsley Fern Code 1.2.png"
            alt="Barnsley Fern Code 1.2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
        	Barnsley Fern Code
          </figcaption>
        </figure>	      
      </section>

<p>Line 1: Imports the random module to generate random numbers for selecting transformations. </p>
<p>Line 2: Imports the pyplot module from matplotlib for plotting the fern. </p>
<p>Line 4: Concise, polite description of the code's intent in lines 5-23. Basically, the functions (f1, f2, f3, f4), are part of a system to create a Barnsley Fern fractal. Each function defines a specific geometric transformation that's applied to points. As a quick example, f1 represents one particular transformation within that system.</p>
<p>Line 5: This line defines a function named f1 that accepts two input values, x and y, representing the coordinates of a point. </p>
<p>Line 6: This line sets the x-coordinate of the point to 0. Regardless of the original x value passed in, it gets overwritten.</p>
<p>Line 7: This line scales the y-coordinate of the point by a factor of 0.16. This effectively shrinks the point's vertical position.</p>
<p>Line 8: This line returns the modified x and y values as a tuple, representing the new coordinates of the point after the transformation.</p>
<p>Line 10: This line defines a function named f2 that accepts two input values, x and y, representing the coordinates of a point. Now, function f2 is a core part of creating the Barnsley Fern fractal; it is is a more complex transformation that involves both scaling and rotation of the input point. </p>
<p>Line 11: This line calculates a new x value (x_new) using a combination of the original x and y. It involves scaling and shifting the coordinates.</p>
<p>Line 12: This line calculates a new y value (y_new) in a similar way, using a different combination of scaling and shifting operations.</p>
<p>Line 13: The function returns the calculated x_new and y_new as a tuple, representing the transformed point.</p>
<p>Line 15: This line defines a function named f3 that accepts two input values, x and y, representing the coordinates of a point.</p>
<p>Line 16: This line calculates the new x-coordinate (x_new) under the given specifications (values and numerical operations) for f3. </p>
<p>Line 17: This line calculates the new y-coordinate (y_new) under the given specifications (values and numerical operations) for f3.</p>
<p>Line 18: Here, the function returns the new coordinates (x_new, y_new) as a tuple for f3. </p>
<p>Line 20: This line defines a function named f4 that accepts two input values, x and y, representing the coordinates of a point.</p>
<p>Line 21: This line calculates the new x-coordinate (x_new) under the given specifications (values and numerical operations) for f4. </p>
<p>Line 22: This line calculates the new y-coordinate (y_new) under the given specifications (values and numerical operations) for f4.</p>
<p>Line 23: Here, the function returns the new coordinates (x_new, y_new) as a tuple for f4. </p>
<p>Line 25: Concise, polite description of the code's intent in line 26.</p>
<p>Line 26: Here we assign the variable probabilities to, essentially, store a list of probabilities. On the RHS, we have [0.01, 0.85, 0.07, 0.07], which is a list containing four probability values. 
	Each value corresponds to one of the four transformation functions (f1, f2, f3, f4) used to create the Barnsley Fern pattern. 
	The values within the lsit each correspond to a percentage value in which a function has a probability of being selected; for example, function f2 is selected with a probability of 85% (0.85).
	By assigning different probabilities to each function, we can create a variety of fern-like patterns. 
	The higher the probability of a function, the more it will influence the final shape. 
	In this case, f2 has the highest probability, making it the most dominant transformation in generating the Barnsley Fern. </p>
<p>Line 28: Concise, polite description of the code's intent in lines 29-46.</p>
<p>Line 29: Here we use def to define the function called barnsley_fern. Note that barnsley_fern takes one argument, iterations, which determines how many points to generate for the fern. </p>
<p>Line 30: This line initializes two variables, x and y, to 0. These represent the starting coordinates of a point.</p>
<p>Line 31: This line creates an empty list called points to store the generated points. </p>
<p>Line 33: This line uses a for loop that runs iterations times, generating a new point in each iteration.</p>
<p>Line 34: Inside our for loop, random.random() generates a random number between 0 and 1, stored in rand.</p>
<p>Lines 35-42: In these lines, we have a series of if and elif statements which compare rand to cumulative probabilities defined in our previously created list called probabilities (which is defined outside of this code and has four values, as elucidated in line 26).
	Based on the random number and probabilities, one of four functions (f1, f2, f3, or f4) is selected. 
	These functions (defined outside of the provided code) apply specific mathematical transformations to the current x and y coordinates.</p>
<p>Line 44: The transformed coordinates are then added as a tuple (x, y) to the points list. </p>
<p>Line 46: After all iterations, the function returns the points list, which now contains a collection of coordinates that represent the Barnsley fern.
	In essence, the barnsley_fern function simulates the growth of the fern by repeatedly applying random transformations to a point's coordinates. 
	The probabilities associated with each transformation determine the overall shape and structure of the resulting fractal pattern.</p>
<p>Line 48: Concise, polite description of the code's intent in lines 49-50.</p>
<p>Line 49: This line sets a variable called iterations to 100000. This variable controls how many times the barnsley_fern function will be executed, essentially determining the number of points that will be generated for the fern. More iterations generally lead to a more detailed and filled-in fern shape.</p>
<p>Line 50: This line calls the barnsley_fern function, passing the iterations value as an argument. The barnsley_fern function is designed to calculate and return a list of (x, y) coordinate pairs that represent points on the fern. The result is stored in the fern_points variable, which will then hold all the points that make up the Barnsley Fern fractal.</p>
<p>Line 52: Concise, polite description of the code's intent in lines 53-57.</p>
<p>Line 53: In this line, fern_points is a list of (x, y) coordinate tuples representing the points of the fern.
	*fern_points unpacks this list into individual tuples.
	zip() combines the corresponding elements of these tuples into two separate tuples: one for the x-values (x_vals) and one for the y-values (y_vals). </p>
<p>Line 54: This line creates a new figure for the plot with a specific size of 6 inches wide and 10 inches tall. This ensures that the fern is displayed with the correct proportions.</p>
<p>Line 55: In this line, plt.scatter() creates a scatter plot.
	x_vals and y_vals provide the data for the x and y coordinates of the points.
	s=0.1 sets the size of the points to be very small (0.1), creating a more detailed and fern-like appearance. 
	color='green' makes the points green, which is a traditional color for the Barnsley Fern. </p>
<p>Line 56: This line adds a title to the plot, simply labeling it "Barnsley Fern".</p>
<p>Line 57: Here, we use plt.show() as the final command that displays the created plot on the screen. Without it, the plot would be generated but not shown, which would be rather sad. </p>


	    
  <figure>
          <img
            src="Barnsley Fern.png"
            alt="Barnsley Fern"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
        	Barnsley Fern 
          </figcaption>
        </figure>	      
      </section>	
	    
<h2>Part 2: L-Systems</h2>

	    
	 <figure>
          <img
            src="L-System Setup Code.png"
            alt="L-System Setup Code"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            L-System Setup Code
          </figcaption>
        </figure>

<p>Line 1: !wget: This part uses a command called wget, which is a tool often used in Linux environments to download files from the internet. The exclamation mark (!) at the beginning tells the Jupyter Notebook to run this line as a shell command, not as regular Python code.
	-O turtle_setup.py: This option specifies that the downloaded file should be saved with the name turtle_setup.py. -O is an option for wget that lets you choose the output file name.
	'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py': This is the URL where the file is located. It's getting the file turtle_setup.py from a GitHub repository. </p>
<p>Line 2: from turtle_setup: This indicates that we're importing things from a file named turtle_setup.py - the one we just downloaded. 
	import *: The asterisk (*) is a wildcard. It means "import everything" from that file. This makes all the functions, classes, and variables defined in turtle_setup.py available for use in the current notebook. 
	</p>
	    
	    <figure>
          <img
            src="Fern Code 1.1.png"
            alt="Fern Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>
        <figure>
          <img
            src="Fern Code 1.2.png"
            alt="Fern Code 1.2"
            width="600"
            height="400"
            loading="lazy"
          />
	<figcaption>
		Fern Code
	</figcaption>
        </figure>

<p>Line 1: Concise, polite description of the code's intent in lines 2-3. </p>
<p>Line 2: This line sets up the drawing environment for the turtle. It's like preparing a canvas or a piece of paper for drawing.</p>
<p>Line 3: This line makes the turtle visible on the screen. By default, the turtle might be hidden, so this command makes it appear as a small arrow or triangle shape, ready to start drawing. </p>
<p>Line 5: Concise, polite description of the code's intent in lines 6-7.</p>
<p>Line 6: This line defines a 2-parameter function called apply_rule. It takes two inputs, char and rules.
	char represents a single character from the L-system's current string, while rules is a dictionary that contains the rules for the L-system.
	These rules define how characters in the string are replaced or transformed. </p>
<p>Line 7: This line is the heart of the function and uses the get() method of the rules dictionary.
	It tries to find the char within the rules dictionary.
	If char is found as a key in the rules, the function returns the value associated with that key (which is the replacement for char according to the L-system rules).
	If char is not found in the rules, the function returns the original char itself (meaning no change is applied to it).
</p>
<p>Line 9: Concise, polite description of the code's intent in lines 10-14. </p>
<p>Line 10: In this line, we use def to define a 3-parameter function called generate_lsystem. 
	Parameter axiom is the starting string or symbol of the L-system. It's like the seed of the fractal. 
	Parameter rules is a dictionary containing the rules for how the L-system evolves. The keys are symbols, and the values are the strings they are replaced with in each iteration.
	Parameter iterations is an integer that determines how many times the rules are applied to the L-system string. More iterations create more complex fractals, which is what we generally like for visual appeal and academic exploration. </p>
<p>Line 11: Here, the function starts by assigning the axiom to a variable called current_string. The axiom is the initial string that the L-system begins with. </p>
<p>Line 12: This is a for loop that runs for the specified number of iterations.</p>
<p>Line 13: In this line, we have apply_rule(char, rules), which is assumed to be a separate function (defined earlier) that takes a character (char) and the rules dictionary. It applies the corresponding rule to the character. If no rule is found for the character, it returns the character itself.
	[apply_rule(char, rules) for char in current_string] is a basically list comprehension. It iterates through each character (char) in the current_string, applies the apply_rule function to it, and creates a new list with the results.
	Finally, ''.join(...) takes the list generated by the list comprehension and joins the elements together into a single string. This new string becomes the updated current_string for the next iteration. </p>
<p>Line 14: In this line, after the loop completes all iterations, the function returns the final current_string, which now represents the generated L-system fractal pattern encoded as a string.</p>
<p>Line 16: Concise, polite description of the code's intent in lines 17-33.</p>
<p>Line 17: In this line, we use def to define a 3-parameter function called draw_lsystem with parameters turtle_string, length, angle. </p>
<p>Line 18: Here, we use [] to create a list called stack. Essentially, this will store the turtle's position and direction whenever it encounters a '[' character, allowing it to return to that state later.</p>
<p>Line 19: This is a for loop that iterates through each character (command) in the turtle_string that represents the L-system instructions. 
	Inside this ofr loop, a series of if and elif statements will check the current command and perform the corresponding action. </p>
<p>Lines 20-21: These lines implement an if command to move the turtle forward by the specified length. </p>
<p>Lines 22-23: These lines hold the else if condition to turn the turtle left by the specified angle. </p>
<p>Line 24-25: These lines hold the else if condition to the turtle right by the specified angle. </p>
<p>Line 26: This is another else if condition within the current for loop with commands in lines 27-29 that will initiate when conditions are appropriate. </p>
<p>Line 27: Here we save the turtle's current position using getx(), gety(). </p>
<p>Line 28: Here we save the turtle's current heading (direction) using heading(). </p>
<p>Line 29: Here we push this position and heading information onto the stack for later retrieval. </p>
<p>Line 30: This is the final else if condition within the current for loop with commands in lines 31-33 that will initiate when conditions are appropriate. </p>
<p>Line 31: This line pops the last saved position and heading from the stack. </p>
<p>Line 32: This line implements the jump() command to move the turtle directly to the saved position without drawing (like lifting pen from paper). </p>
<p>Line 33: This line implements the face() command to set the turtle's heading to the saved direction. </p>
<p> In essence, function draw_lsystem takes a string of L-system instructions (turtle_string) and uses the Turtle graphics library to draw the corresponding fractal. The length and angle parameters control the size and shape of the fractal.
	Essentially, we can describe these seemingly complicated instructions in a simple manner as follows: 
	'F': will draw forward; '+': will turn left; '-': will turn right; '[': will save current position and heading; and ']': will restore previous position and heading. </p>
<p>Line 35: Concise, polite description of the code's intent in lines 36-39.</p>
<p>Line 36: In this line, the variable rules is assigned a dictionary that holds the rules of our L-system. The key 'F' represents a symbol in the L-system. 
	The value 'FF+[+F-F-F]-[-F+F+F]' is the replacement rule for 'F'. 
	This means whenever the system encounters an 'F', it will replace it with this sequence of characters. </p>
<p>Line 38: In this line, variable axiom is assigned the starting point (or initial string) for the L-system. 
	Think of it like the seed of the pattern. Here, the axiom is simply 'F'.</p>
<p>Line 39: In this line, variable iterations determines how many times the L-system rules will be applied.
	Each iteration makes the pattern more complex by substituting symbols with their replacement rules. 
	Here, it's set to 4, meaning the rules will be applied 4 times. </p>
<p>Line 41: Concise, polite description of the code's intent in line 42.</p>
<p>Line 42: In this line, turtle_string is a variable that will store the generated string. This string contains a sequence of characters that represent turtle commands (previously mentioned) like "move forward," "turn left," and "turn right."
	Now, generate_lsystem(axiom, rules, iterations)  calls the generate_lsystem function to create the instruction string with the three parameters: axiom; rules; and iterations, which were described in depth earlier.
</p>
<p>Line 44: Concise, polite description of the code's intent in lines 45-47.</p>
<p>Line 45: This line moves the turtle to a specific position on the screen without drawing anything. Think of it as lifting the pen and placing the turtle at the coordinates (400, 500). The coordinate system starts from the center of the screen. </p>
<p>Line 46: This line sets the direction the turtle is facing. 0 degrees means the turtle is facing right (east). So, this line orients the turtle to face east. </p>
<p>Line 47: This line sets the color of the pen the turtle is holding to green. Any subsequent lines drawn by the turtle will be green, which is typically ideal for creation of a fern. </p>
<p>Line 49: Concise, polite description of the code's intent in lines 50-52.</p>
<p>Line 50: Here we set our length variable to 8. This variable determines how far the turtle will move forward when it encounters an 'F' in the turtle_string. Basically, it defines the length of each branch in our fractal tree.</p>
<p>Line 51: Here we set our angle variable to 25. This variable determines the angle by which the turtle will turn when it encounters a '+' or '-' in the turtle_string. '+' signifies a left turn, and '-' signifies a right turn. This angle is crucial for creating the branching structure of the fractal tree.</p>
<p>Line 52: In this line, draw_lsystem is the function we defined previously to interpret the L-system string and control the turtle's movements. 
	Our 3 parameters have already been described previously, but for consistency, we will briefly detail them as follows: 
	turtle_string is the string generated earlier using the L-system rules. It contains the sequence of commands ('F', '+', '-', '[', ']') that guide the turtle's drawing;
	length is the length of each branch, which we set to 8; 
	angle is the angle of each turn, which we set to 25. </p>
<p>Line 54: Concise, polite description of the code's intent in line 55.</p>
<p>Line 55: In our final line of code, we use the function show(). This function is part of the turtle graphics library. After the turtle has finished drawing, calling show() will pause execution and display the image/animation drawn by the turtle so far. </p>


        <figure>
          <img
            src="Fern .png"
            alt="Fern"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Fern
          </figcaption>
        </figure>	    

<h2>Part 3: Hilbert Curves</h2>

        <figure>
          <img
            src="Hilbert Curves Setup Code.png"
            alt="Hilbert Curves Setup Code"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Hilbert Curves Setup Code
          </figcaption>
        </figure>	

<p>Line 1: !wget: This part uses a command called wget, which is a tool often used in Linux environments to download files from the internet. The exclamation mark (!) at the beginning tells the Jupyter Notebook to run this line as a shell command, not as regular Python code.
	-O turtle_setup.py: This option specifies that the downloaded file should be saved with the name turtle_setup.py. -O is an option for wget that lets you choose the output file name.
	'https://raw.githubusercontent.com/williamedwardhahn/fractal25/refs/heads/main/turtle_setup.py': This is the URL where the file is located. It's getting the file turtle_setup.py from a GitHub repository. </p>
<p>Line 2: from turtle_setup: This indicates that we're importing things from a file named turtle_setup.py - the one we just downloaded. 
	import *: The asterisk (*) is a wildcard. It means "import everything" from that file. This makes all the functions, classes, and variables defined in turtle_setup.py available for use in the current notebook. 
	</p>

        <figure>
          <img
            src="Hilbert Curves Code 1.1.png"
            alt="Hilbert Curves Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>	
        <figure>
          <img
            src="Hilbert Curves Code 1.2.png"
            alt="Hilbert Curves Code 1.2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Hilbert Curves Code
          </figcaption>
        </figure>

<p>Line 1: Concise, polite description of the code's intent in line 2.</p>
<p>Line 2: In this line, we use import to brings the tools from the math module into our current script for use.
math is the name of the specific toolbox.</p>
<p>Line 4: Concise, polite description of the code's intent in lines 5-6.</p>
<p>Line 5: This line is a function call that initializes and sets up the drawing environment for the turtle graphics. Think of it as creating a blank canvas for the turtle to draw on. </p>
<p>Line 6: </p>
<p>Line 8: Concise, polite description of the code's intent in lines 9-10.</p>
<p>Line 9: </p>
<p>Line 10: </p>
<p>Line 12: Concise, polite description of the code's intent in lines 13-18.</p>
<p>Line 13: </p>
<p>Line 14: </p>
<p>Line 15: </p>
<p>Line 16: </p>
<p>Line 17: </p>
<p>Line 18: </p>
<p>Line 20: Concise, polite description of the code's intent in lines 21-31.</p>
<p>Line 21: </p>
<p>Line 22: </p>
<p>Line 23: </p>
<p>Line 24: </p>
<p>Line 25: </p>
<p>Line 26: </p>
<p>Line 27: </p>
<p>Line 28: </p>
<p>Line 29: </p>
<p>Line 30: </p>
<p>Line 31: </p>
<p>Line 33: Concise, polite description of the code's intent in lines 34-40.</p>
<p>Line 34: </p>
<p>Line 35: </p>
<p>Line 36: </p>
<p>Line 37: </p>
<p>Line 38: </p>
<p>Line 39: </p>
<p>Line 40: </p>
<p>Line 42: Concise, polite description of the code's intent in line 43.</p>
<p>Line 43: </p>
<p>Line 45: Concise, polite description of the code's intent in lines 46-48.</p>
<p>Line 46: </p>
<p>Line 47: </p>
<p>Line 48: </p>
<p>Line 50: Concise, polite description of the code's intent in lines 51-53.</p>
<p>Line 51: </p>
<p>Line 52: </p>
<p>Line 53: </p>
<p>Line 55: Concise, polite description of the code's intent in line 56.</p>
<p>Line 56: </p>
<p>Line 58: Concise, polite description of the code's intent in line 59.</p>
<p>Line 59: </p>
	    

        <figure>
          <img
            src="Hilbert Curve.png"
            alt="Hilbert Curve"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Hilbert Curve
          </figcaption>
        </figure>	


      




   

     

	    
      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>

<p> This module introduced both the Mandelbrot Set and Julia Set, as well as described the foundation of fractals in Nature in general. The Mandelbrot Set is a massive treasure trove of data and pictorial beauty; in fact, even Julia Sets 
	can be found in the Mandelbrot Set when recreated in image form. Fractal geometry is a very significant field due to the simplicity of formulae involved and their surprisingly complex results; because the formulae are so
basic, any scientist from any field has the capability to explore fractal geometry, lending their expertise to the development of the field overall. Consequently, more unique findings are possible, since those with specialities outside 
of mathematics or physics may make discoveries otherwise overlooked by mathematicians or physicists unversed in other fields. Visualizing the Julia and Mandelbrot Sets (Mandelbrot in particular), would not have been possible without the aid of advanced computer programming, 
	hence their surprisingly historically late detection by mathematicians. Through powerful coding programs like Python, we are able to dive deeper into the exploration of the Mandelbrot Set; technological developments of computers has enable greater resolution,
speed, and iteration capabilities in calculations and, consquently, image creation. This module also emphasized the importance of the use of color when plotting functions. Again, color seems like a relatively simple concept like fractal formulas; however, when used conscientiously in advanced coding programs, we 
can easily see how color plays a vital role in understanding extremely complex sets of data, as evidenced in this module when displaying the Mandlebrot Set and Julia Set. The human eye alone could never detect many finer details within fractals,
	even those found in Nature, necessitating the implementation of color maps within advanced programming.  </p>


  <h2>Works Cited (MLA)</h2>    
	      
<p> “Julia Set.” Wikipedia, Wikimedia Foundation, 4 February 2025, https://en.wikipedia.org/wiki/Julia_set. Accessed 17 April 2025. </p>

<p>“Matplotlib Colormaps.” Geeks for Geeks, https://www.geeksforgeeks.org/matplotlib-colors-colormap-class-in-python/. Accessed 17 April 2025. </p>

<p> "Michael Barnsley." Wikipedia, Wikimedia Foundation, 29 June 2024, https://en.wikipedia.org/wiki/Michael_Barnsley. Accessed 17 April 2025. </p>

		
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
