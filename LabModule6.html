<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report: Enter the Matrix</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Module 6 Enter the Matrix</h1>
    <p class="author">
      [Leigh Brawner] <br />
      [March 22nd, 2025]
    </p>
  </header>
  



  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
        This module focuses on the creation of grids of points using Python coding; we can use transformation of functions
	to manipulate grid overall shape, simultaneoulsy creating interesting and highly intricate patterns based on relatively 
	simple function rules. We will further demonstrate this by generating unique variations.
	</p>

        <figure>
          <img
            src="Cantor and Smith.png"
            alt="Cantor Set Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Georg Cantor and Henry John Stephen Smith
          </figcaption>
        </figure>	      
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      <h2>Original Grid Generation and Transformation Functions</h2>
	      
        <h4>Original Grid Code and Plot 1</h4>
        <p>
          Below is the Colab section showcasing the original Grid Code.
        </p>

        <figure>
          <img
            src="Grid Code 1.png"
            alt="Grid Code 1"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Original Grid Code 1
          </figcaption>
        </figure>

	 <p> Line 1: this line uses import to install our first library used for our code written in lines 5-23. 
			numpy, which is imported as np, is a fundamental library specifically for numerical operations in Python, 
			particularly used for working with arrays and matrices. This will be useful when we generate our rows and
	 		columns of colored dots. </p>
	 <p> Line 2: this line uses import to install our second library used for our code written in lines 5-23.
			matplotlib.pyplot, which is imported as plt, is a common library used in creating static, interactive, 
		 	and animated visualizations in Python. Similar to numpy, using plt makes the code cleaner and easier to read. </p>
	 <p> Line 4: this line is polite description of the intent of the code in lines 5-9. Essentially, we will be creating a a simple 2D 
		 	grid of points using the library, NumPy. This function will create a grid of points within a square area spanning from -1 to 1 
		 	on the x and y axes (2-Dimensional). The size parameter controls the density of the points in the grid. 
		 	More points will generate with a larger size, thus creating a denser grid.</p>
	 <p> Line 5: this line defines a function named generate_grid that takes one input argument: size. 
		 	This size argument will determine how many points are created along each dimension of the grid. </p>
 	 <p> Line 6: this line defines a function, np.linspace, which comes from the NumPy library (np) and generates a sequence of evenly spaced numbers within a specified range.
	 		The -1, 1 specifies the start and end points of our range. So in this case, the sequence of numbers will be generated between -1 and 1.
		 	size will determine overall the number of points to generate within our range. Finally, our result will be stored in variable x, 
		 	which logically will represent the x-coordinates of the grid points. </p>
	 <p> Line 7: this line does the same thing as the previous one but stores the results in the variable y, representing the y-coordinates of the grid points. </p>
	 <p> Line 8: this line creates the function np.meshgrid, which takes two 1D arrays (like our x and y) to create two 2D arrays representing the x and y coordinates of 
		 	all grid points. The final result is stored in the variable grid, which now contains the complete 2D grid of points. </p>
	 <p> Line 9: this line uses return to return the formulated grid, making it available for use outside of the function. </p>
	 <p> Line 11: this line is polite description of the code's intention for lines 12-17.Essentially, this upcoming set of lines sets up the visualization. </p>
	 <p> Line 12: this line uses def to define the one-parameter function, plot_grid. Now, note that (grid) represents our 2 dimensional grid of points. 
		 	Visually, it will be a tuple containing two NumPy arrays, one for the x-coordinates and one for the y-coordinates. </p>
	 <p> Line 13: this line is interesting, as it actually separates the grid tuple into two variables: x_grid and y_grid. Ultimately,
		 	this will result in more understandable code that is easier to work with. 
		 	x_grid will, logically, hold the x-coordinates of the grid points, and y_grid, logically, will hold the y-coordinates.</p>
	 <p> Line 14: this line uses matplotlib.pyplot module (imported as plt) to create a new figure.
			figsize=(10, 10) sets the size of the figure to be 10 inches by 10 inches. Note that we can alter these values, if desired, to change the overall figure size. </p>
 	 <p> Line 15: this line uses plt.scatter , the function from matplotlib.pyplot used to create scatter plots. 
	 		x_grid and y_grid both provide data points used in the plot.
			s=1 sets the size of the points in the scatter plot to be very small (1 point). 
			color='blue' makes the points blue. </p>
	 <p> Line 16: this long line simply creates the plot's title. It uses an f-string to dynamically create the title text, including the dimensions of the grid based on the length of the x_grid and y_grid arrays. 
	 		{len(x_grid)}: is the part that calculates the length of the x_grid using the len() function and inserts it into the string. x_grid represents the x-coordinates of the grid points. 
			x is just the character "x", used here to visually separate grid dimensions in the title.
			{len(y_grid)}: this works like x_grid, and calculates the length of y_grid (the y-coordinates) and inserts it into the string. 
 			plt.title() is the function that sets the title of the plot. </p>
	 <p> Line 17: this line simply displays the created plot to the user. It's essential to use plt.show() for actually seeing the visualization. </p>
	 <p> Line 19: this line is polite description of the intent of the code in line 20, which will basically set the size of the grid. </p>
	 <p> Line 20: This line creates a variable called size and assigns it to a value, in this case, 50. 
		 	This size variable will control how many points are generated in each dimension of the grid (both x and y). We can alter it at will. </p>
	 <p> Line 22: this line is polite description of the code's intent in lines 23-24. Basically, these lines will both generate and plot the 2D grid of points and then visualizes it using a scatter plot. </p>
	 <p> Line 23: this line calls the generate_grid function, which we defined in lines 5-9. It passes the size variable, currently set at 50, as an argument.
			The generate_grid function creates a 2D grid of points and returns it.
			The returned grid is then stored in the grid variable. </p>
	 <p> Line 24: this line calls the plot_grid function, which was defined in lines 12-17. It passes the grid, created in line 23, as an argument.
	 		The plot_grid function takes this grid and displays it as a scatter plot using matplotlib.pyplot.
			Each point on the grid is represented as a small blue dot. The plot includes a title indicating the size of the grid. </p>
	      
	<figure>
          <img
            src="Grid Plot 1.png"
            alt="Grid Plot 1"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 1
	  </figcaption>
        </figure>

<h4>Original Grid Code and Plot 2</h4>
	      
<figure>
          <img
            src="Grid Code 2.png"
            alt="Grid Code 2"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Code 2
	  </figcaption>
        </figure>

	 <p> Line 1: </p>
	 <p> Line 2: </p>
	 <p> Line 3: </p>
	 <p> Line 4: </p>
 	 <p> Line 5: </p>
	 <p> Line 6: </p>
	 <p> Line 8: </p>
	 <p> Line 9: </p>
	 <p> Line 11: </p>
	 <p> Line 12: </p>
	 <p> Line 14: </p>
	 <p> Line 15: </p>
	 	      
<figure>
          <img
            src="Grid Plot 2.png"
            alt="Grid Plot 2"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 2
	  </figcaption>
        </figure>
	      
<h4>Original Grid Code and Plot 3</h4>	
	      
<figure>
          <img
            src="Grid Code 3.png"
            alt="Grid Code 3"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Code 3
	  </figcaption>
        </figure>

	 <p> Line 1: </p>
	 <p> Line 2: </p>
	 <p> Line 4: </p>
	 <p> Line 5: </p>
	 <p> Line 7: </p>
	 <p> Line 8: </p>	
	      
<figure>
          <img
            src="Grid Plot 3.png"
            alt="Grid Plot 3"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 3
	  </figcaption>
        </figure>

<h4>Original Grid Code and Plot 4</h4>
	      
<figure>
          <img
            src="Grid Code 4.png"
            alt="Grid Code 4"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Code 4
	  </figcaption>
        </figure>	      
	 
	 
	 <p> Line 1: </p>
	 <p> Line 2: </p>
	 <p> Line 4: </p>
	 <p> Line 5: </p>
	 <p> Line 7: </p>
	 <p> Line 8: </p>	
	      
	<figure>
          <img
            src="Grid Plot 4.png"
            alt="Grid Plot 4"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 4
	  </figcaption>
        </figure>

<h2>Unique Variations</h2>	    
	      
<figure>
          <img
            src="Cantor Set Image 4.png"
            alt="Cantor Set Image 4"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Variation 4
	  </figcaption>
        </figure>	      
	      
<figure>
          <img
            src="Cantor Set Code 4.png"
            alt="Cantor Set Code 4"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Variation 4, Associated Code
	  </figcaption>
        </figure>

	      
<figure>
          <img
            src="Cantor Set Image 5.png"
            alt="Cantor Set Image 5"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Variation 5
	  </figcaption>
        </figure>	      
	      
<figure>
          <img
            src="Cantor Set Code 5.png"
            alt="Cantor Set Code 5"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Variation 5, Associated Code
	  </figcaption>
        </figure>	      

<figure>
          <img
            src="Cantor Set Image 6.png"
            alt="Cantor Set Image 6"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Variation 6
	  </figcaption>
        </figure>	      
	      
<figure>
          <img
            src="Cantor Set Code 6.png"
            alt="Cantor Set Code 6"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Cantor Set Variation 6, Associated Code
	  </figcaption>
        </figure>	      

	      
<h2> Cantor Set and Sierpinski Carpet</h2>      
<p>   A two-dimensional fractal, commonly referred to as the Sierpinski Carpet, has a strong relationship to the Cantor Set (Sierpinski Carpet). Instead of trisecting a line segment, removing the middle section, and repeating the process as in the Cantor Set, the Sierpinski Carpet is formed through the division of 
	a square into nine smaller squares, with the middle square removed (Cantor Set, Sierpinski Carpet). Remaining squares are then subdivided into nine each, again removing the middle square; this process can continue 
	infinitely like the Cantor Set (Cantor Set, Sierpinski Carpet). </p>

<figure>
          <img
            src="Lab Module 3 Sierpinski Carpet Result.png"
            alt="Lab Module 3 Sierpinski Carpet Result"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Carpet
          </figcaption>
        </figure>      

	      
	      <figure>
          <img
            src="Lab Module 3 Sierpinski Carpet Code.png"
            alt="Lab Module 3 Sierpinski Carpet Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
             Sierpinski Carpet Code
          </figcaption>
        </figure>	      

<p> Important Note: this is the code for creating a Sierpinski Carpet using Python's Turtle Graphics, but in order for it to function in Colab, we would also need to install the associated turtle library. To save time, space, and maintain focus on the Cantor Set, we will not include the image of the library. </p>	      
<p> Line 1: we use # to begin a brief description of our following code for the Sierpinski Carpet; particularly, a Sierpinski Carpet of order 4. </p>
<p> Line 2: initializeTurtle() is the function call that sets up the drawing environment for the turtle, i.e., the drawing canvas. </p>
<p> Line 3: showturtle() reveals the turtle icon, enabling visualization of the turtle’s movement/position. </p>
<p> Lines 5-8: this is analogous to the code used in the equilateral triangle creation. </p>
<p> Line 5: we use def to define a function called draw_square that has one parameter, called length. Length will be the overall size of the generated square. </p>
<p> Line 6: we start a for loop in given range. This means the loop will run a set number of times, as specified in the range. Here, since we have for _ in range(4): , the loop will run 4 times total before stopping (which is logical, since a square has four equal sides). </p> 
<p> Line 7: the function forward() is called to move the turtle by the specified length; specifying length will occur in line 26. </p>	   
<p> Line 8: the function left() is used to swivel the turtle by the given degrees after the turtle completes its specified length; since we have left(90), our turtle will rotate left by a 90 angle after concluding said distance. This is logical, since a square is formed of 4 angles, each of which is 90 degrees. </p>
<p> Line 11: we use def to define a function called sierpinski_carpet with two parameters, length and order. Length represents the function’s line length; in this case, the square's length. Order determines the associated drawn line’s complexity, i.e., the overall complexity of the Sierpinski Carpet. </p>
<p> Lines 12-13: begins an if statement (conditional statement) with the base case condition that when order == 0 is met, the turtle will move forward by its given length. Note that == is the comparison operator. In other words, if order is 0, then turtle simply draws the square function defined earlier (with accompanied given length, of course).</p>
<p> Line 14: this begins the else component of our if statement, which occurs when the given base case is not met, i.e., when order is not 0. </p>
<p> Line 15: starts the for loop in range (4) </p>
<p> Line 16: the Sierpinski Carpet fundamentally contains smaller squares within squares, namely 9 per square. This line of code initiates the first smaller square within the defined sierpinski function, sierpinski_carpet(length / 3, order -1). Here, current length is reduced by one-third using the mathematical division operator, and order is reduced by 1. </p>
<p> Line 17: the function forward() moves the turtle forward, in this case by length / 3. </p>
<p> Line 18: draws the second smaller square, similarly to line 15. </p>
<p> Line 19: the function forward() moves the turtle forward, in this case by length / 3. </p>
<p> Line 20: the function forward() moves the turtle forward, in this case by length / 3. </p>
<p> Line 21: the left() function rotates the turtle left by the given degrees. In this case, left(90) rotates the turtle 90 degrees to the left (a right angle). No movement is made, only rotation.</p>
<p> Line 23: jump(x,y) is the function that moves the turtle to the specified x-y coordinates on the canvas without drawing any line. Here, we start at jump(300,500). </p>
<p> Line 24: face() is a function that points the turtle in a specific direction; here, face(90) points the turtle North. </p>
<p> Line 25: color() is the function that specifies the line color; here, color(‘aqua’) specifies line color to be aqua (a pretty blue). </p>
<p> Line 26: length is the variable that sets the line length. This will be the overall size of the generated sierpinski carpet (smaller numbers will yield smaller sierpinski carpets, whereas larger numbers will yield larger sierpinski carpets). Here, our length is 400. </p>
<p> Line 27: order is the variable used to assign different complexity values to the sierpinski carpet; higher order yields greater complexity and thus a more intricate pattern of the fractal overall. Here, the order is 4. </p>
<p> Line 28: the recursive function sierpinski_carpet is called to finally draw the sierpinski carpet with its associated two parameters, length and order, variables assigned in lines 26 and 27, respectively. /p>
<p> Line 30: show() displays the final result, i.e., our Sierpinski Carpet. </p>
	      
	      
		
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        
	<p> In this module report, we successfully described the Cantor Set discovered by mathematician Henry John Stephen Smith, which was made
		famous by the more well-known set theory founder, Georg Cantor. We elucidated the 41-line Python code written to create the Cantor Set function and thus generate
		images showcasing its properties. We then modified the code to formulate new variations of the Cantor Set to showcase their generated images. Of particular interest was
		a variation known as the Sierpinski Carpet, which is subdivided into 9 smaller entities instead of 3 smaller entities as in the Cantor Set. This
		minimization process through successive iterations, when represented pictorially with powerful computer coding like Python, clearly showcases the simulated Infinite Dust entitling this module.  </p>

	  <h2>Works Cited (MLA)</h2>    


<p> Barile, Margherita and Weisstein, Eric W. "Cantor Set." From MathWorld—A Wolfram Web Resource. https://mathworld.wolfram.com/CantorSet.html </p>

<p> “Cantor set.” Wikipedia, Wikimedia Foundation, 2 March 2025, https://en.wikipedia.org/wiki/Cantor_set </p>

<p> “Georg Cantor.” Wikipedia, Wikimedia Foundation, 16 March 2025, https://en.wikipedia.org/wiki/Georg_Cantor </p>

<p> “Henry John Stephen Smith.” Wikipedia, Wikimedia Foundation, 5 October 2024, https://en.wikipedia.org/wiki/Henry_John_Stephen_Smith </p>

<p> "Sierpinski carpet." Wikipedia, Wikimedia Foundation, 28 September 2024, https://en.wikipedia.org/wiki/Sierpi%C5%84ski_carpet </p>
	      
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
