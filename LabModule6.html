<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report: Enter the Matrix</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Module 6 Enter the Matrix</h1>
    <p class="author">
      [Leigh Brawner] <br />
      [March 22nd, 2025]
    </p>
  </header>
  



  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
        This module focuses on the creation of grids of points using Python coding; we can use transformation of functions
	to manipulate grid overall shape, simultaneoulsy creating interesting and highly intricate patterns based on relatively 
	simple function rules. We will further demonstrate this by generating unique variations.
	</p>

	<p>Before we begin, we will discuss the viewing material issued to us this week.  </p>
	      
	<p> This week’s viewing material is a film dedicated to Benoit Mandelbrot, narrated by mathematician Franco Vivaldi.

Vivaldi states that in between the real and imaginary are fractals, computer generated pictures of simple formulas, where the pictures are infinitely detailed. Vivaldi claims that a formula having any pattern is a new idea. Mandelbrot initiated the concept that these patterns have hidden meanings; consequently, others following Mandelbrot have explored this idea. Mandelbrot fondly called fractals the geometry of nature due to their inherent complex and organic looking shapes; however, they also captured the dynamics of nature in a way the geometry of simple squares and circles never could. Since fractals were discovered, artists have explored their visual beauty; others have turned fractals into music so that they could actually hear the sound of an equation in addition to seeing it.  As a mathematician, Vivaldi doggedly resolves to know if fractals can tell him anything about the world we live in. 

Benoit Mandelbrot’s discovery began with his strong desire to uncover something unique to research in mathematics, a new field; he did not want to compete with giant figures already established in the mathematical world and pick at their leftovers. He attributes his independent attitude to that of his youth, a time in which he actively rebelled against the power and trend of the day. Mathematically, he was mainly interested in the real world, particularly desiring to work with shapes and not cold formulas.

Vivaldi states that the beauty of fractals lies in their creation through simple formulas rather than complex/exotic ones. He further explains that these relatively easy formulas were learned by most people in school. Mandelbrot unlocked the dynamic side of geometry using iteration—i.e., feedback. Vivaldi demonstrates this concept using a parabola and an old computer. He emphasizes the use of complex numbers for 2-D image modeling. He mentions the importance of discovering the Julia Set, which is actually a set of related shapes (there are an infinite number of them). Mandelbrot famously divided the massive Julia Set into two families: those made of a single piece; and those integrated into infinitely many fragments. Eventually, he found the Mandelbrot Set, a complete library of Julia Sets in which every miniscule detail represents a Julia Set. Mandelbrot spent many nights creating pictures of his discovery, repeatedly emphasizing that it was a time of simultaneous fatigue and joy in his life. Colleagues of Mandelbrot have since explored higher dimensions, such as Alan Norton. Norton initially considered these fractals as decorative, and hoped to discover a real-world purpose for them—naturally, doing so required studying higher dimensions. He believed that these fractal images were just a slice, or snapshot, of a higher-dimensional topology, particularly concentrating on the 4th dimension, what is currently believed to be the dimension human beings exist in.

Interestingly, narrator Vivaldi showcases trees (even going so far as having a bonsai plant sitting on his desk). He briefly mentions basic rules behind plant development, specifically: stems; leaves; and flowers. Dr. Brian Goodwin substantiates Vivaldi’s contention on plant growth, stating the biconditional argument that “…the process is the form and the form is the process.” Evolution is an equivalent exploration of rules of this kind, enabling us to determine which forms are either possible or impossible to generate in biological systems.
Iterations are a powerful tool implemented in understanding complex shapes and the evolution process of shapes into new forms. What lies at the heart of fractals is iterations, which use simple rules to yield fantastically complex final products. 

I believe FAU’s Dr. Richard Voss worked under Benoit Mandelbrot, and created famous computerized fractal images.
</p>
        <figure>
          <img
            src="Julia and Mandelbrot.png"
            alt="Julia and Mandelbrot"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
        	Benoit Mandelbrot (left), Julia Set (top right), Mandelbrot Set (bottom right)
          </figcaption>
        </figure>	      
      </section>


     
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->
	<!-- -------------------------------------------------------------------------------------------- -->


      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      <h2>Original Grid Generation and Transformation Functions</h2>
	      
        <h4>Original Grid Code and Plot 1</h4>
        <p>
          Below is the Colab section showcasing the original Grid Code.
        </p>

        <figure>
          <img
            src="Grid Code 1.png"
            alt="Grid Code 1"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
            Original Grid Code 1
          </figcaption>
        </figure>

	 <p> Line 1: this line uses import to install our first library used for our code written in lines 5-23. 
			numpy, which is imported as np, is a fundamental library specifically for numerical operations in Python, 
			particularly used for working with arrays and matrices. This will be useful when we generate our rows and
	 		columns of colored dots. </p>
	 <p> Line 2: this line uses import to install our second library used for our code written in lines 5-23.
			matplotlib.pyplot, which is imported as plt, is a common library used in creating static, interactive, 
		 	and animated visualizations in Python. Similar to numpy, using plt makes the code cleaner and easier to read. </p>
	 <p> Line 4: this line is polite description of the intent of the code in lines 5-9. Essentially, we will be creating a a simple 2D 
		 	grid of points using the library, NumPy. This function will create a grid of points within a square area spanning from -1 to 1 
		 	on the x and y axes (2-Dimensional). The size parameter controls the density of the points in the grid. 
		 	More points will generate with a larger size, thus creating a denser grid.</p>
	 <p> Line 5: this line defines a function named generate_grid that takes one input argument: size. 
		 	This size argument will determine how many points are created along each dimension of the grid. </p>
 	 <p> Line 6: this line defines a function, np.linspace, which comes from the NumPy library (np) and generates a sequence of evenly spaced numbers within a specified range.
	 		The -1, 1 specifies the start and end points of our range. So in this case, the sequence of numbers will be generated between -1 and 1.
		 	size will determine overall the number of points to generate within our range. Finally, our result will be stored in variable x, 
		 	which logically will represent the x-coordinates of the grid points. </p>
	 <p> Line 7: this line does the same thing as the previous one but stores the results in the variable y, representing the y-coordinates of the grid points. </p>
	 <p> Line 8: this line creates the function np.meshgrid, which takes two 1D arrays (like our x and y) to create two 2D arrays representing the x and y coordinates of 
		 	all grid points. The final result is stored in the variable grid, which now contains the complete 2D grid of points. </p>
	 <p> Line 9: this line uses return to return the formulated grid, making it available for use outside of the function. </p>
	 <p> Line 11: this line is polite description of the code's intention for lines 12-17.Essentially, this upcoming set of lines sets up the visualization. </p>
	 <p> Line 12: this line uses def to define the one-parameter function, plot_grid. Now, note that (grid) represents our 2 dimensional grid of points. 
		 	Visually, it will be a tuple containing two NumPy arrays, one for the x-coordinates and one for the y-coordinates. </p>
	 <p> Line 13: this line is interesting, as it actually separates the grid tuple into two variables: x_grid and y_grid. Ultimately,
		 	this will result in more understandable code that is easier to work with. 
		 	x_grid will, logically, hold the x-coordinates of the grid points, and y_grid, logically, will hold the y-coordinates.</p>
	 <p> Line 14: this line uses matplotlib.pyplot module (imported as plt) to create a new figure.
			figsize=(10, 10) sets the size of the figure to be 10 inches by 10 inches. Note that we can alter these values, if desired, to change the overall figure size. </p>
 	 <p> Line 15: this line uses plt.scatter , the function from matplotlib.pyplot used to create scatter plots. 
	 		x_grid and y_grid both provide data points used in the plot.
			s=1 sets the size of the points in the scatter plot to be very small (1 point). 
			color='blue' makes the points blue. </p>
	 <p> Line 16: this long line simply creates the plot's title. It uses an f-string to dynamically create the title text, including the dimensions of the grid based on the length of the x_grid and y_grid arrays. 
	 		{len(x_grid)}: is the part that calculates the length of the x_grid using the len() function and inserts it into the string. x_grid represents the x-coordinates of the grid points. 
			x is just the character "x", used here to visually separate grid dimensions in the title.
			{len(y_grid)}: this works like x_grid, and calculates the length of y_grid (the y-coordinates) and inserts it into the string. 
 			plt.title() is the function that sets the title of the plot. </p>
	 <p> Line 17: this line simply displays the created plot to the user. It's essential to use plt.show() for actually seeing the visualization. </p>
	 <p> Line 19: this line is polite description of the intent of the code in line 20, which will basically set the size of the grid. </p>
	 <p> Line 20: This line creates a variable called size and assigns it to a value, in this case, 50. 
		 	This size variable will control how many points are generated in each dimension of the grid (both x and y). We can alter it at will. </p>
	 <p> Line 22: this line is polite description of the code's intent in lines 23-24. Basically, these lines will both generate and plot the 2D grid of points and then visualizes it using a scatter plot. </p>
	 <p> Line 23: this line calls the generate_grid function, which we defined in lines 5-9. It passes the size variable, currently set at 50, as an argument.
			The generate_grid function creates a 2D grid of points and returns it.
			The returned grid is then stored in the grid variable. </p>
	 <p> Line 24: this line calls the plot_grid function, which was defined in lines 12-17. It passes the grid, created in line 23, as an argument.
	 		The plot_grid function takes this grid and displays it as a scatter plot using matplotlib.pyplot.
			Each point on the grid is represented as a small blue dot. The plot includes a title indicating the size of the grid. </p>
	      
	<figure>
          <img
            src="Grid Plot 1.png"
            alt="Grid Plot 1"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 1
	  </figcaption>
        </figure>

<h4>Original Grid Code and Plot 2</h4>
	      
<figure>
          <img
            src="Grid Code 2.png"
            alt="Grid Code 2"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Code 2
	  </figcaption>
        </figure>

	 <p> Line 1: this line defines a 2-parameter function called iterative_transform. The parameters are called grid and iterations.
	 		grid represents the 2D grid of points generated by the previously created generate_grid function, and iterations
	 		represents an integer specifying how many times a transformation should be applied. </p>
	 <p> Line 2: this line separates the grid variable into two separate variables, x_grid and y_grid; these represent the x and y coordinates of the grid points, respectively.</p>
	 <p> Line 3: this line combines the x_grid and y_grid formed in line 2 in order to create a complex plane. 
                      1j represents the imaginary unit in Python; interestingly, it is j instead of i, but this is a known Python characteristic.
			z now holds complex numbers, where the real part is from x_grid, and the imaginary part from y_grid. 
	 		</p>
	 <p> Line 4: this line starts a for loop. The variable i acts as a counter; i.e., it takes on a new value in each cycle of the loop until the loop ends.
	 		in connects the counter variable, i, to the sequence of values it will iterate through. Finally, range(iterations) will generate the sequence of 
		 	numbers from 0 to iterations - 1. iterations is a parameter, discussed earlier, defining how many times the transformation should be applied. </p>
 	 <p> Line 5: this line applies the actual transformation. Each point in the complex plane represented by z is squared, and then 0.5 is subtracted from the result. 
		 	The result is then assigned back to z, effectively updating the point's position in the complex plane. Now, we can alter these values, the square and 0.5 subtracted,
	 		to a different function, which will yield a different result. We will do this later on. </p>
	 <p> Line 6: this line uses return; the function is going to send back values to the place where it was called.
	 		np.real(z) extracts the real component of the complex number z while
	 		np.imag(z) extracts the imaginary component of the complex number z. </p>
	 <p> Line 8: this line is polite description of the code's intent in line 9. Essentially, it will set the number of iterations. </p>
	 <p> Line 9: recall that we defined iterations to be a variable that stores an integer value.
			Currently, a value of 1 is assigned to this variable. The iterative_transform function will use the value
		 	to determine how many times to loop and apply the transformation. </p>
	 <p> Line 11: this is polite description of the code's intent in line 12. Basically, it will apply the iterative transformation under its current conditions. </p>
	 <p> Line 12: this line creates a variable called fractal_grid. The function iterative_transform, which we first defined in line 1, uses 2 parameters, grid and iterations.
	 		The fractal_grid variable will store the result of the iterative_transform function. </p>
	 <p> Line 14: this line is polite description of the intent of the code in line line 15. At this point, it will plot the fractal grid. </p>
	 <p> Line 15: this line contains the plot_grid() function, which uses fractal_grid data to create a visual representation of it as a scatter plot."</p>
	 	      
<figure>
          <img
            src="Grid Plot 2.png"
            alt="Grid Plot 2"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 2
	  </figcaption>
        </figure>
	      
<h4>Original Grid Code and Plot 3</h4>	
	      
<figure>
          <img
            src="Grid Code 3.png"
            alt="Grid Code 3"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Code 3
	  </figcaption>
        </figure>

	 <p> Line 1: this line is polite description of the intent of the code in line 2. Basically, we are going to set the number of iterations we want to do. </p>
	 <p> Line 2: this line contains the variable, iterations, and currently has the variable set at 2, though we can easily change this.
	 	 	the iterations variable will generate the number of transformations performed on the x,y points within our grid.	</p>
	 <p> Line 4: this line is polite description of the code's intent in line 5. Basically, we will be applying our iterative transformation function. This will use the
	 		iterations variable and its associated value as discussed in line 4, as well as aforementioned coding, such as the grid variable iterative_transform function. </p>
	 <p> Line 5: this line is essentially creating a new variable called fractal_grid. The right hand side of this new variable stores the function iterative_transform(grid, iterations), which 
			was created earlier in another block of code. This is a 2-parameter function, with parameters grid and iterations. grid is variable storing the original grid of points of the transformation.
			iterations is the variable controling how many times the transformation is applied, currently 2. Successive terations modifies the points, yielding a more sophisticated, and thus more interesting, fractal.
	 		</p>
	 <p> Line 7: this line is polite description of the code's intent in line 8. Basically, we're at the final stage to plot our fractal grid.</p>
	 <p> Line 8: this line implements the plot_grid function on the variable created in line 5, fractal_grid. This enables us to showcase the transformed grid, and shows a scatter plot of x,y points after the set number of transformations have been performed.
</p>	
	      
<figure>
          <img
            src="Grid Plot 3.png"
            alt="Grid Plot 3"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 3
	  </figcaption>
        </figure>

<h4>Original Grid Code and Plot 4</h4>
	      
<figure>
          <img
            src="Grid Code 4.png"
            alt="Grid Code 4"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Code 4
	  </figcaption>
        </figure>	      
	 
<p>The code in this code block works precisely the same as described in the previous section, but with one minor difference. The iterations variable in line 2 is
	set to store 3 instead of 2, i.e., iterations = 3 instead of iterations = 2. This means that we are performing an additional transformation, 
	which will yield a more sophisticated looking fractal in the form of dots on a scatterplot, and thus a variety of fractal dot patterns that are somewhat reminiscent to an ink-blot test.
	At first glance, setting iterations at 3 instead of 2 appears to do little to change the pattern overall; however, further inspection reveals numerous altered details. The additional
	iteration seems to have flipped the image, leaving a triangular open space on the right hand side of the grid instead of the left hand side. Dots appear to be more widespread, although 
	maintaining a clear pattern; further inspection reveals that this initial speculation is correct, as the grid has a (labeled) x-axis of -5 to 10 as opposed to 
	the previous a-axis of -4 to 2, as well as a larger (labeled) y-axis of -15 to 15 instead of a y-axis of -3 to 3. This implies that the heavy concentration of dots section is actually larger
	in diameter with iterations = 3 compared to iterations = 2. </p>
	      
	<figure>
          <img
            src="Grid Plot 4.png"
            alt="Grid Plot 4"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Original Grid Plot 4
	  </figcaption>
        </figure>

<h2>Unique Variations</h2>	    
	  <p> Below are unique variations resulting from alteration of the code discussed in the previous section. </p> 

	      <h4>Unique Variation 1</h4>
<figure>
          <img
            src="Variation 1 Code.png"
            alt="Variation 1 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 1 Code
	  </figcaption>
        </figure>	      

<p> In this example, we have simply modified the original base plotting code shown in Figure 1 in the previous section. 
	We have altered the boundaries of where the points (the number of which will be variable size) will generate on the x,y graph in lines 6-7. 
	We have changed the figure size in line 14, increasing x to a maximum of 15 and decreasing y to a maximum of 5;
	note that 15 does not actually show up visibly on the graph unless we alter x in line 6 from its maximum of 1 to a maximum of 15. This further 
	demonstrates the connection between lines 6-7 and line 14, better showcasing what the code generates. 
	In line 15, we enlarged the overall point size from s=1 to s=100; here, we also changed color from blue to orange.
	In line 16, we have modified the plot title to read Two Dimensional instead of 2-D.
	Finally, in line 20, we made the grid sparser by decreasing size=50 to size=10. The resulting image with these modifications is below. </p>
	      
<figure>
          <img
            src="Variation 1 Image.png"
            alt="Variation 1 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 1 Image
	  </figcaption>
        </figure>

<p> Interestingly, changes to the base code will affect our iterative_transform function formed in the original second code block.
	Without making changes to the associated iterative_transform code, we can see these changes in the image below. </p>
	      
	      
<figure>
          <img
            src="Variation 1.1 Image.png"
            alt="Variation 1.1 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 1.1 Image, iterative_transform function with 1 iteration
	  </figcaption>
        </figure>	      

<p>Expectedly, changes to the base code will impact our fractal_grid function; our first image below showcases 2 iterations, 
	whereas our second image below showcases 3 iterations. </p>      
	      
<figure>
          <img
            src="Variation 1.2 Image.png"
            alt="Variation 1.2 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 1.2 Image, fractal_grid function with 2 iterations
	  </figcaption>
        </figure>	      

<figure>
          <img
            src="Variation 1.3 Image.png"
            alt="Variation 1.3 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 1.3 Image, fractal_grid function with 3 iterations
	  </figcaption>
        </figure>	      
	      
<h4>Unique Variation 2</h4>
    
<figure>
          <img
            src="Variation 2 Code.png"
            alt="Variation 2 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2 Code
	  </figcaption>
        </figure>	      

<p> In this example, we have again modified the original base plotting code. 
	We have altered the boundaries of where the points (the number of which will be variable size) will generate on the x,y graph in lines 6-7. 
	We have changed the figure size in line 14: the x line has a maximum of 5 and the y line has a maximum of 5.
	In line 15, we raised overall point size from s=1 to s=10; here, we also changed color from blue to green.
	In line 16, we have modified the plot title to read Two Dimensional instead of 2-D.
	Finally, in line 20, we left the grid at size=50. The resulting image with these modifications is below. </p>
	      
<figure>
          <img
            src="Variation 2 Image.png"
            alt="Variation 2 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2 Image
	  </figcaption>
        </figure>

<p> Although these alterations of the base code don't appear very different from our previous alterations, they affect our iterative_transform function 
	formed in the original second code block differently. We will show this by, again, not making changes to the associated iterative_transform code. </p>
	      
	      
<figure>
          <img
            src="Variation 2.1 Image.png"
            alt="Variation 2.1 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2.1 Image, iterative_transform function with 1 iteration
	  </figcaption>
        </figure>	      

<p>Changes to the base code will once more impact our fractal_grid function; our first image below showcases 2 iterations, 
	whereas our second image below showcases 3 iterations. </p>      
	      
<figure>
          <img
            src="Variation 2.2 Image.png"
            alt="Variation 2.2 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2.2 Image, fractal_grid function with 2 iterations
	  </figcaption>
        </figure>	      

<figure>
          <img
            src="Variation 2.3 Image.png"
            alt="Variation 2.3 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2.3 Image, fractal_grid function with 3 iterations
	  </figcaption>
        </figure>	      
	   
<h4>Unique Variation 3</h4>	   
	      
<figure>
          <img
            src="Variation 3 Code.png"
            alt="Variation 3 Code"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 3 Code
	  </figcaption>
        </figure>	      

<p> In this example, we have again modified the original base plotting code, this time only slightly.
	In line 15, we raised overall point size from s=1 to s=5; here, we also changed color from blue to purple.
	In line 20, we raised grid from size=50 to size=75. We will not show the resulting base grid. </p>
	      
<figure>
          <img
            src="Variation 2 Image.png"
            alt="Variation 2 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2 Image
	  </figcaption>
        </figure>

<p> Although these alterations of the base code don't appear very different from our previous alterations, they affect our iterative_transform function 
	formed in the original second code block differently. We will show this by, again, not making changes to the associated iterative_transform code. </p>
	      
	      
<figure>
          <img
            src="Variation 2.1 Image.png"
            alt="Variation 2.1 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2.1 Image, iterative_transform function with 1 iteration
	  </figcaption>
        </figure>	      

<p>Changes to the base code will once more impact our fractal_grid function; our first image below showcases 2 iterations, 
	whereas our second image below showcases 3 iterations. </p>      
	      
<figure>
          <img
            src="Variation 2.2 Image.png"
            alt="Variation 2.2 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2.2 Image, fractal_grid function with 2 iterations
	  </figcaption>
        </figure>	      

<figure>
          <img
            src="Variation 2.3 Image.png"
            alt="Variation 2.3 Image"
            width="500"
            height="500"
            loading="lazy"
          />
          <figcaption>
		Variation 2.3 Image, fractal_grid function with 3 iterations
	  </figcaption>
        </figure>	      

		
      </section>

      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        
	<p> In this module report, we successfully described the Cantor Set discovered by mathematician Henry John Stephen Smith, which was made
		famous by the more well-known set theory founder, Georg Cantor. We elucidated the 41-line Python code written to create the Cantor Set function and thus generate
		images showcasing its properties. We then modified the code to formulate new variations of the Cantor Set to showcase their generated images. Of particular interest was
		a variation known as the Sierpinski Carpet, which is subdivided into 9 smaller entities instead of 3 smaller entities as in the Cantor Set. This
		minimization process through successive iterations, when represented pictorially with powerful computer coding like Python, clearly showcases the simulated Infinite Dust entitling this module.  </p>

	  <h2>Works Cited (MLA)</h2>    


<p> “Benoit Mandelbrot.” Wikipedia, Wikimedia Foundation, 9 March 2025, https://en.wikipedia.org/wiki/Benoit_Mandelbrot </p>

<p> “Julia Set.” Wikipedia, Wikimedia Foundation, 4 February 2025, https://en.wikipedia.org/wiki/Julia_set </p>

<p> “Mandelbrot Set.” Wikipedia, Wikimedia Foundation, 23 March 2025, https://en.wikipedia.org/wiki/Mandelbrot_set </p>
	      
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
