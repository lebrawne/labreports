<!-- INTRODUCTION SECTION -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<!-- -------------------------------------------------------------------------------------------- -->
<html>
<head> <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="stylesheet" href="https://latex.vercel.app/style.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"/><script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]}};</script>

<title>Fractal Geometry Lab Report</title>

</head>
	
<body id="top">




  <header>
    <h1>Fractal Geometry Lab Report: Modules 7 & 8</h1>
    <p class="author">
      [Leigh Brawner] <br />
      [April 13th, 2025]
    </p>
  </header>
  


  <main>
    <article class="indent-pars">
      
      <!-- INTRODUCTION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="introduction">
        <h2>Introduction</h2>
        <p>
          This lab report combines Module 7, which deals with the Mandelbrot Set, and Module 8, which focuses on the Julia Set. We begin with an old documentary Fractals--The Colors of Infinity, by Arthur C Clark, the screenwriter for the film: 2001 A Space Odyssey. 
        </p>

	      	    <figure>
          <img
            src="Mandelbrot.png"
            alt="Mandelbrot"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Benoit Mandelbrot (Documentary Image)
          </figcaption>
        </figure>

<p>Mandelbrot set is one of the most beautiful and remarkable discovery in history of mathematics, only discovered recently less than 50 years ago in 1980. Changed our view of the universe and give us a better understanding of its workings. Narrated by Arthur C. Clark, science and science fiction writer. Professor Ian Stuart of mathematics at Warwick universities, Dr. Michael Barnsley professor of mathematics at georgia institute of technology who received a 2.5 million dollar grant in 1991 to develop fractal image compression systems, Dr. Stephen Hawking a mathematician and cosmologist and author of a Brief History of Time, and Dr. Benoit Mandelbrot whose unorthodox mathematics led to the discovery of both the Mandelbrot Set and Fractal Geometry. The Mandelbrot Set captures interest with its generated image alone; despite its significantly complex appearance, Dr. Michael Barnsley reiterates its authenticity by substantiating its existence by many other researchers, including: mathematicians; computer scientists; and students. He summarizes with his statement that “Such things that can be magnified forever” and “with infinite precision do exist, but they’re not touchable.” Sometimes colorfully nicknamed as the Thumbprint of God. Magnifying the Mandelbrot Set reveals mini Mandelbrots; Clark comments that they are almost identical, if not entirely identical, to the original set. Continual magnification yields new patterns and images due to the set’s inherent infinite complexity; however, despite its complexity, the allure of the Mandelbrot Set lies in its relative simplicity in formulation, which seems rather counterintuitive. Why the Mandelbrot Set wasn’t discovered either in history is most likely due to the fact that its creation lies with performing an incredible number of successive iterations; intense iterative mathematics is really only possible with the conception of modern computer technology. Mandelbrot first glimpsed this M-Set in 1980 while working for IBM. </p>     


	      	<figure>
          <img
            src="Gaston Julia.png"
            alt="Gaston Julia"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Gaston Julia (Documentary Image)
          </figcaption>
        </figure>	      


<p>Interestingly, the foundation of the Mandelbrot Set was initially discovered shortly before the conclusion of World War I by French mathematician Gaston Julia. Like the Mandelbrot Set, Julia Sets could not be visualized until the development of computers later that century.  Now, when magnifying a small part of the Mandelbrot Set, you can get what looks like a Julia Set; other sets contained within the Mandelbrot Set substantiates its importance. Simple formulas can yield complicated results, as Mandelbrot imparts, using Newton’s Gravitational Law as another example. Professor Ian Stuart adds another example to this, Einstein’s Theory of Relativity. But, as narrator Clark reminds his audience, Einstein’s formula stands for physical quantities, while Mandelbrot’s Set more simply stands for numbers (coordinates that are positions on the complex plane). For the formula of the Mandelbrot Set, they show a double arrow to emphasize how the numbers flow in both directions, constantly feeding back on themselves (i.e., iteration); I’ve never seen this symbol before this video. </p>


	      	    <figure>
          <img
            src="M-Set Formula.png"
            alt="M-Set Formula"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
        	Mandelbrot Set Formula (Documentary Image)
          </figcaption>
        </figure>

	      
<p>The Mandelbrot Set is considered to be the most famous fractal; note that the name fractal was also concocted by Mandelbrot, who wanted to a word that conveyed fragmentation and irregularity. Mandelbrot describes fractals as geometrical shapes with which we are strongly used to, and compares the magnification process on fractals as an extraterrestrial approaching a landmass on Earth, whose details in Nature become solidly more complex the closer the extraterrestrial gets. Fractals appear throughout Nature, even in the DNA of a butterfly’s egg to form the insect’s characteristic colorful patterns. We see these patterns in trees and ferns, as emphasized in a previous module. Back then, Dr. Stephen Hawking believed that there was a real limit to the universe rather than go on infinitely like the Mandelbrot Set. Clark regales how Faraday, considered the father of electricity, stated to his then prime minister that he would one day be able to tax electricity; he was right. Clark uses this story to describe the enormous commercial value fractals potentially have. Stuart conveys that fractals, as of the 1980’s, were more of an intellectual field due to the then limits of computers; this is consistent with most mathematical developments, in which the idea arrives first before being translated into something more pragmatic. Barnsley states that scientists now have the option of drawing fractal curves through their data rather than a mere straight line or measure some fractal dimension and do science. Fractals offer a much better description of the visual world, and due to the simplicity of the formulas, fractal science is approachable to virtually all scientific disciplines, enabling many diverse approaches and potential unique findings. Mandelbrot substantiates the that fractals paint a much more similar representation of Nature than nonfractal geometry could offer.</p>	      


    	    <figure>
          <img
            src="Fractal Tree.png"
            alt="Fractal Tree"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
        	Fractal Tree (Documentary Image)
          </figcaption>
        </figure>	      
      </section>

<p>Barnsley proposes that fractal geometry could enable humanity to construct innovative engineering devices, including buildings.
Magnifying the Mandelbrot Set yields much more information now, than compared to the film’s production date, with the evolution of computer technology and programming. The development of fractal image compression systems by Barnsley and his company in the 1990’s led to giant companies using it, such as Microsoft. Barnsley is also credited for discovering the collage theorem and the Barnsley Fern. Fractal image compression came to Barnsley in a series of dreams and nightmares over the course of 20 years. Barnsley’s image compression system enabled compression of images using vastly fewer bits for storage. It also enabled satellites to take, compress, and send images to Earth. We can obviously see how fractals play a role in facial recognition and artificial intelligence. Fractal geometry has surprising applications in medicine. The blood circulatory system of the human body is a kind of fractal. Clark states that the most important fractal of all in the human body is the small complex wiring system of the brain; he believes that the brain will one day be understood thanks to fractal geometry, in particular the Mandelbrot Set. He also states that he has heard certain drugs can induce states of the mind which reproduce visions of the Mandelbrot Set. Points out that Mandela and Mandelbrot Set have some eerie similarities. Mandelbrot (the man) points out the art of fractals. Mandelbrot states that upon discovering the Mandelbrot Set, he never had a feeling of invention, that he never had the feeling that his imagination was rich enough to invent all of the extraordinary things he was discovering; they were just there, even though nobody had seen them before.
</p>

  <figure>
          <img
            src="Eyes.png"
            alt="Eyes"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
        	Barnsley's Compressed Eyes (Documentary Image)
          </figcaption>
        </figure>	      
      </section>	
	    
<h2>Module 7: Infinite Complexity</h2>

	    
        <figure>
          <img
            src="Mandelbrot Set Code 1.1.png"
            alt="Mandelbrot Set Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>

	    
	 <figure>
          <img
            src="Mandelbrot Set Code 1.2.png"
            alt="Mandelbrot Set Code 1.2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Original Mandelbrot Set Code 
          </figcaption>
        </figure>

<p>Lines 1-3: these lines import 3 libraries implemented in creating the mandelbrot function. </p>
<p>Line 1: we import NumPy, a library for numerical computations in Python that provides tools for working with arrays, matrices, and mathematical functions. </p>
<p>Line 2: we import pyplot module from the Matplotlib library. pyplot provides a simple interface for formulating different types of plots, including line plots, scatter plots, and images.
	Matplotlib is a library for creating visualizations in Python. </p>
<p>Line 3: Numba is a just-in-time (JIT) compiler for Python that has the potential to speed up numerical computations, especially within loops.
The jit decorator marks functions for optimization by its associated library, Numba.</p>
<p>Lines 5-13: this block of code develops our mandelbrot function which will be implemented in creating the overall Mandelbrot Set. </p>
<p>Line 5: polite, concise description of the code's intent in lines 5-13. </p>
<p>Line 6: we defined jit (and JIT) previously in line 3 as a decorator from the Numba library; basically, it will compile our function for faster execution, and does so with nopython=True, which activates the Python interpreter and thus enables its potential for better performance overall. </p>
<p>Line 7: here we define 2-parameter mandelbrot function, labeling parameters as c and max_iter. Note that c stands for a complex number and max_iter is an integer specififying the total desired iterations we want to perform. </p>
<p>Line 8: the variable z initializes some complex number, in this case, z is set to 0. It stores the result of the iterative calculation in the Mandelbrot formula. </p>
<p>Line 9: this just starts an iteration counter for n; in this case, n is set to go to 0. </p>
<p>Line 10: this is a while loop that uses the logical conjunction, and, to signify two conditions that must be met for calculations to continue. 
	Our first condition is that the absolute value of vairable z (defined in line 8) is less than or equal to 2. 
	Our second condition is that iteration count n (defined in line 9) is less than the chosen max_iter variable. </p>
<p>Line 11: here we applie the Mandelbrot formula, updating z with each successive iteration. It uses * to square the current value of z, then adds the original complex number c (our mandelbrot function's first parameter). </p>
<p>Line 12: this is simply our iteration counter, which uses += to determine our increment of n to be 1. </p> 
<p>Line 13: here the function returns the final value of n, iterations, upon completion of our while loop. This value determines the color of the corresponding point when displaying the overall Mandelbrot Set.</p>
<p>Lines 15-26: this block of code basically formulates the Mandelbrot Set function. </p>
<p>Line 15: polite, concise description of the code's intent in lines 16-26.</p>
<p>Line 16: we defined jit (and JIT) previously in line 3 as a decorator from the Numba library; basically, it will compile our function for faster execution, and does so with nopython=True, which activates the Python interpreter and thus enables its potential for better performance overall. </p>
<p>Line 17: here we use def to define our 7-parameter function, mandelbrot_set. 
	variables xmin, xmax are minimum and maximum values for the real (x) axis of the plot; 
	variables ymin, ymax are minimum and maximum values for the imaginary (y) axis of the plot;
	variables width, height are the pixel dimensions of our resulting image;
	and variable max_iter is maximum iterations used in generating each point in the complex plane.	
	</p>
<p>Lines 18-19: these lines create the complex plane grid.</p>
<p>Line 18: here we assign variable r1 to width number of points between xmin and xmax, representing the real (x) coordinates, and
	np.linspace will create evenly spaced values within this given range.</p>
<p>Line 19: here we assign variable r2 to the height number of points between ymin and ymax, representing the imaginary (y) coordinates. 
	Again, np.linspace will create evenly spaced values within this given range.</p>
<p>Line 20: here we assign variable n3 to the value on the RHS, which are the Mandelbrot calculations for each point in the complex plane.
	Note that np.empty creates an empty array with given dimensions (height/width).</p>
<p>Lines 22-24: two nested for loops for determining Mandelbrot Set height and width parameter values within ranges. This is used to create the visual representation of the Mandelbrot set. </p>
<p>Line 22: first for loop with a range for width. Here, i will be the real part of the complex number, corresponding to the generated horizontal x-coordinate pixel. </p>
<p>Line 23: second for loop with a range for height. Here, j will be the imaginary part of the complex number, corresponding to the generated vertical y-coordinate pixel. 
	Interestingly, j is the imaginary unit in Python rather than the typical mathematical represenation i. </p>
<p>Line 24: r1[i] + 1j * r2[j] creates a complex number.
r1[i] will be the real part of the complex number, corresponding to the x-coordinate similarly described in line 22;
r2[j] provides the imaginary part of the complex number, corresponding to the y-coordinate similarly described in line 23;
1j represents the imaginary unit (square root of -1), also as described in line 23.  
 Both arguments, (r1[i] + 1j * r2[j]) and max_iter, will be passed to the mandelbrot function; note that this is the mandelbrot function and NOT the mandelbrot set function.
The result returned by the mandelbrot function will then be assigned to the array, n3, at the current pixel location (n3[i, j]). </p>
<p>Line 26: here, we use return to return n3. After the loops have processed all pixels, array n3, now containing the calculated values for the entire image, is returned. Array n3 will then be used to visualize the Mandelbrot set.</p>
<p>Lines 28-31: we introduced 7-parameters in our mandelbrot_set function defined in line 17. Here we will be able to manually choose our values to assign to each of our 7-parameters. </p>
<p>Line 28: concise, polite description of the code's intent in lines 29-31. </p>
<p>Line 29: these 4 parameters define the boundaries of the rectangular region in the complex plane that will be visualized.</p>
<p>Line 30: these 2 parameters determine the resolution or the number of points calculated within the defined region. width represents the points along horizontal axis, height the points along the vertical axis. Logically, higher values yield greater resolution at the cost of a higher time for generation. </p>
<p>Line 31: our final parameter sets the maximum number of iterations the algorithm will perform for each point in the complex plane. </p>
<p>Line 33: concise, polite description of the code intent in line 34. </p>
<p>Line 34: here, we are just assigning the mandelbrot_set function (previously created) to the variable n3 for simpler/shorter coding in later lines. It's easier, more efficient, and less cumbersome writing to write n3 rather than constantly repeat the entire function. </p>
<p>Lines 35-38: description and code of the parameters for the initial zoom level. </p>
<p>Line 35: concise, polite description of the code's intent in lines 36-38. </p>
<p>Line 36: this defines the overall zoom in region (rectangular). xmin, ymin represents the bottom left corner coordinate and xmax, ymax represents the top right coordinate. x-values along the horizontal represent the real part, whereas y-values represent the imaginary part. </p>
<p>Line 37: as discussed earlier, parameters height and width determine the overall resolution of the final image. For example, height =800, width=800 will generate an 800x800 pixel image. Larger pixel images result in greater waiting periods for images to generate than smaller pixel counts.  </p>
<p>Line 38: the parameter representing the maximum number of iterations performed for each point in the complex plane. Like the height and width parameters, max_iter can increase the complexity of the overall image when assigned larger values, but time duration will understandably increase as the program runs.  </p>
<p>Line 40: concise, polite description of the code's intent in line 41. </p>
<p>Line 41: this line assigns the zoomed in portion of the mandelbrot_set function to varaible n3. </p>
<p>Lines 43-48: this code block is necessary for finally plotting the Madelbrot Set using the previous code. </p>
<p>Line 43: concise, polite description of the code's intent in lines 44-48.</p>
<p>Line 44: here we create a new figure for the plot with a specific size of 10 inches by 10 inches using the figure() function from the matplotlib.pyplot module (imported as plt).</p>
<p>Line 45: plt.imshow() is a function that displays data as an image. n3 calls our data in array form, then uses T to transpose the data.
	extent=[xmin, xmax, ymin, ymax] specifies the boundaries of the image on the x and y axes, essentially defining the zoom level and area of the Mandelbrot set being visualized using the xmin, xmax, ymin, and ymax variables. 
	sets the colormap to 'hot', meaning the image will use a color gradient ranging from black to red to yellow and white, often used for visualizing heat or intensity. </p>
<p>Line 46: this line adds a colorbar to the plot, providing a visual representation of the color mapping to the values in the Mandelbrot set. It helps in understanding the relationship between the colors and the calculated values.</p>
<p>Line 47: this line just sets the title of the plot. </p>
<p>Line 48: plt.show() simply displays the final plot, making the code come to life, so to speak. </p>


	    <figure>
          <img
            src="Mandelbrot Set Image.png"
            alt="Mandelbrot Set Image"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Original Mandelbrot Set Image 
          </figcaption>
        </figure>

<h3>Mandelbrot Set Explorations</h3>

        <figure>
          <img
            src="M-Set Code 1.png"
            alt="M-Set Code 1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>

        <figure>
          <img
            src="M-Set Code 1.1.png"
            alt="M-Set Set Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Mandelbrot Set Color Variation Code (Twilight colormap)
          </figcaption>
        </figure>	    
<p>We can extend the code slightly to change color maps. In line 4, we use from to take from library, matplotlib, by using import to use its associated colormaps module.
This module specifically provides a collection of colormaps that can be used to color plots. 
Colormaps are essentially a range of colors that can be used to represent data values in a visualization. Therefore, in line 46, we can now alter the cmap parameter. 
So, instead of the 'hot' colormap, we can pick another, like 'twilight'. There are many other colormaps to pick from, including but not limited to:
‘magma’; ‘inferno’; ‘plasma’; ‘viridis’; ‘cividis’; ‘twilight’; ‘twilight_shifted’; ‘turbo’; ‘Blues’; ‘BrBG’; ‘BuGn’; ‘BuPu’; ‘CMRmap’;
‘GnBu’; ‘Greens’; ‘Greys’; ‘OrRd’; ‘Oranges’; etc. (Matplotlib). </p>

        <figure>
          <img
            src="M-Set 1.png"
            alt="M-Set 1"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Color Variation 1 Image (Twilight colormap)
          </figcaption>
        </figure>	


        <figure>
          <img
            src="M-Set Code 2.png"
            alt="M-Set Code 2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Variation 2 Code (Plasma colormap)
          </figcaption>
        </figure>	

<p> Here, we have modified the parameters for the initial zoom level and changed the colormap to 'plasma'. </p>

        <figure>
          <img
            src="M-Set 2.png"
            alt="M-Set 2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Variation 2 Image (Plasma colormap)
          </figcaption>
        </figure>
	    

        <figure>
          <img
            src="M-Set Code 3.png"
            alt="M-Set Code 3"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Variation 3 Code (Viridis colormap)
          </figcaption>
        </figure>	

<p> Here, we have modified the imaginary unit 1j to be 1.52j in line 25, and changed the colormap to 'viridis'. 
Using this colormap, we can see Mandelbrot Sets in vibrant yellow. Of particular interest is the largest Mandelbrot Set in the top right corner.  </p>

        <figure>
          <img
            src="M-Set 3.png"
            alt="M-Set 3"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Variation 3 Image (Viridis colormap)
          </figcaption>
        </figure>
	    

<figure>
          <img
            src="M-Set Code 4.png"
            alt="M-Set Code 4"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Variation 4 Code (Viridis colormap)
          </figcaption>
        </figure>	

<p> Here, we have left the colormap as 'Viridis', and have zoomed in on a Mandelbrot Set with altered initial zoom values in line 2. </p>

        <figure>
          <img
            src="M-Set 4.png"
            alt="M-Set 4"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Mandelbrot Set Variation 4 Image (Viridis colormap)
          </figcaption>
        </figure>	    



	    
<h2>Module 8: Julia Set</h2>

        <figure>
          <img
            src="Julia Set Code 1.1.png"
            alt="Original Julia Set Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>

        <figure>
          <img
            src="Julia Set Code 1.2.png"
            alt="Original Julia Set Code 1.2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Original Julia Set Code
          </figcaption>
        </figure>	    

<p>Lines 1-3: these lines import 3 libraries implemented in creating the Julia Set function. </p>
<p>Line 1: we import NumPy, a library for numerical computations in Python that provides tools for working with arrays, matrices, and mathematical functions. </p>
<p>Line 2: we import pyplot module from the Matplotlib library. pyplot provides a simple interface for formulating different types of plots, including line plots, scatter plots, and images.
	Matplotlib is a library for creating visualizations in Python. </p>
<p>Line 3: Numba is a just-in-time (JIT) compiler for Python that has the potential to speed up numerical computations, especially within loops.
The jit decorator marks functions for optimization by its associated library, Numba.</p>	
<p>Lines 5-21: this block of code develops our julia_set function which will be implemented in creating the overall Julia Set. </p>	
<p>Line 5: concise, polite description of the code's intent in lines 6-21. </p>
<p>Line 6: we defined jit (and JIT) previously in line 3 as a decorator from the Numba library; basically, it will compile our function for faster execution, and does so with nopython=True, which activates the Python interpreter and thus enables its potential for better performance overall. </p>
<p>Line 7: here we use def to define our 8-parameter function, julia_set :
	variable c represents a complex number for generating the Julia set that influences the shape and patterns of the overall fractal;
	variables xmin, xmax are minimum and maximum values for the real (x) axis of the plot; 
	variables ymin, ymax are minimum and maximum values for the imaginary (y) axis of the plot;
	variables width, height are the pixel dimensions of our resulting image;
	and variable max_iter is maximum iterations used in generating each point in the complex plane.	
	</p>
<p>Lines 8-10: these lines create the complex plane grid.</p>
<p>Line 8: here we assign variable r1 to width number of points between xmin and xmax, representing the real (x) coordinates, and
	np.linspace will create evenly spaced values within this given range.</p>
<p>Line 10: here we assign variable r2 to the height number of points between ymin and ymax, representing the imaginary (y) coordinates. 
	Again, np.linspace will create evenly spaced values within this given range.</p>
<p>Line 10: here we assign variable n3 to the value on the RHS, which are the Julia calculations for each point in the complex plane.
	Note that np.empty creates an empty array with given dimensions (height/width).</p>	
<p>Lines 12-21: this code block implements loops for iterating points within the grid and performing calculations at each point before storing the all results within an array. </p>	    
<p>Line 12: first for loop with a range for width. Here, i will be the real part of the complex number, corresponding to the generated horizontal x-coordinate pixel. </p>
<p>Line 13: second for loop with a range for height. Here, j will be the imaginary part of the complex number, corresponding to the generated vertical y-coordinate pixel. 
	Interestingly, j is the imaginary unit in Python rather than the typical mathematical represenation i. </p>
<p>Line 14: here we define the complex number z and its stipulations. So the real part is taken from the r1 array at index i; the imaginary part is taken from the r2 array at index j multiplied by 1j (representing the imaginary unit). This will be the initial point on the complex plane that iteration starts from.</p>
<p>Line 15: this is the counter n that keeps track of the number of iterations; it is initialized at 0. </p>
<p>Line 16: this starts a while loop which is the heart of the Julia set calculation. It runs as long as the absolute value (magnitude) of z is less than or equal to 2 and the iteration count n is less than max_iter (maximum iterations). </p>
<p>Line 17: in this line, the Julia set formula is applied. The complex number z is squared with constant c added to the result. z is constantly updated for the next iteration.</p>
<p>Line 18: this is simply our iteration counter, which uses += to determine our increment of n to be 1. </p> 
<p>Line 19: The final value of n after the loop ends is stored in the n3 array at the position (i, j). This value represents how quickly the sequence diverges (goes to infinity) for that specific point.</p>
<p>Line 21: return command returns the n3 array that contains the calculated values for each point in the grid, which determine the color of that point in the Julia set visualization. Like in the previous Mandelbrot Set, color is an important detail necessary for greater understanding of the generated fractal. </p>
<p>Lines 23-26: we introduced 7-parameters in our mandelbrot_set function defined in line 17. Here we will be able to manually choose our values to assign to each of our 7-parameters. </p>
<p>Line 23: concise, polite description of the code's intent in lines 24-26. </p>
<p>Line 24: these 4 parameters define the boundaries of the rectangular region in the complex plane that will be visualized. </p>
<p>Line 25: these 2 parameters determine the resolution or the number of points calculated within the defined region. width represents the points along horizontal axis, height the points along the vertical axis. Logically, higher values yield greater resolution at the cost of a higher time for generation. </p>
<p>Line 26: our final parameter sets the maximum number of iterations the algorithm will perform for each point in the complex plane. </p>
<p>Line 28: concise, polite description of the code's intent in line 29. </p>
<p>Line 29: assigns variable c to the value of complex(), which is a function used to create a complex number. Here, -0.8 is the real part while 0.156 is the imaginary part. </p>
<p>Line 31: concise, polite description of the code's intent in line 32.</p>
<p>Line 32: here we finally generate the 8-parameter Julia Set, and assign the results determined on the RHS of the equation to a variable, n3. </p>
<p>Lines 34-39: this code block is necessary for finally plotting the Julia Set using the previous code. </p>


<p>Line 34: concise, polite description of the code's intent in lines 34-39.</p>
<p>Line 35: here we create a new figure for the plot with a specific size of 10 inches by 10 inches using the figure() function from the matplotlib.pyplot module (imported as plt).</p>
<p>Line 36: plt.imshow() is a function that displays data as an image. n3 calls our data in array form, then uses T to transpose the data.
	extent=[xmin, xmax, ymin, ymax] specifies the boundaries of the image on the x and y axes, essentially defining the zoom level and area of the Mandelbrot set being visualized using the xmin, xmax, ymin, and ymax variables. 
	sets the colormap to 'hot', meaning the image will use a color gradient ranging from black to red to yellow and white, often used for visualizing heat or intensity.
	interpolation='bilinear' will determine how the pixels are interpolated to create a smooth image; 'bilinear' interpolation uses a weighted average of the neighboring pixels, resulting in a smoother appearance. </p>
<p>Line 37: this line adds a colorbar to the plot, providing a visual representation of the color mapping to the values in the Julia set. It helps in understanding the relationship between the colors and the calculated values, and is vital in displaying the Julia Set. </p>
<p>Line 38: this line just sets the title of the plot. Interestingly, we use {c} to incorporate the currently set value of the complex constant c. </p>
<p>Line 39: plt.show() simply displays the final plot, making the code come to life, so to speak. </p>
        <figure>
          <img
            src="Julia Set Image.png"
            alt="Original Julia Set Image"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Original Julia Set Image
          </figcaption>
        </figure>	 	    

<h3>Julia Set Explorations</h3>

        <figure>
          <img
            src="J-Set Code 1.png"
            alt="J-Set Code 1"
            width="600"
            height="400"
            loading="lazy"
          />
        </figure>

        <figure>
          <img
            src="J-Set Code 1.1.png"
            alt="J-Set Set Code 1.1"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
            Julia Set Color Variation 1 Code (Hot colormap)
          </figcaption>
        </figure>	    
<p>Just like in the previously discussed Mandelbrot Set Code, we can extend the Julia Set code slightly to change color maps. In line 4, we use from to take from library, matplotlib, by using import to use its associated colormaps module.
This module specifically provides a collection of colormaps that can be used to color plots. 
Colormaps are essentially a range of colors that can be used to represent data values in a visualization. Therefore, in line 36, we can now alter the cmap parameter. 
So, instead of the 'hot' colormap, we can pick another. However, we will keep this variation as 'hot' in order to emphasize our slight alterations in line 29. 
Here, we change the real part from -0.8 to -0.78, left the imaginary part at 0.156. This demonstrates how different the fractal can appear with a relatively minor change, 
emphasized by keeping our colormap on 'hot' with cmap.
</p>	    

        <figure>
          <img
            src="J-Set 1.png"
            alt="J-Set 1"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Color Variation 1 Image (Hot colormap)
          </figcaption>
        </figure>	

 <figure>
          <img
            src="J-Set Code 2.png"
            alt="J-Set Code 2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 2 Code (Twilight_shifted colormap)
          </figcaption>
        </figure>	

<p> Here, we have modified our variable c assigned to the complex number. We have a real part of 0.78 and imaginary part of -0.12. Note that we changed the colormap to 'twilight_shifted'.
The resulting image is somewhat reminiscent to an unknown biological image. </p>

        <figure>
          <img
            src="J-Set 2.png"
            alt="J-Set 2"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 2 Image (Twilight_shifted colormap)
          </figcaption>
        </figure>


<figure>
          <img
            src="J-Set Code 3.png"
            alt="J-Set Code 3"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 3 Code (Inferno colormap)
          </figcaption>
        </figure>	

<p> Here, we have modified z function in line 17. Here, we have changed z*z+c to z*z*z-1. We have a real part of -0.1 and imaginary part of 0.651. Note that we changed the colormap to 'inferno'.
Changing the function, i.e. variable z in line 17, was inspired by Newton's iteration (Julia). </p>

        <figure>
          <img
            src="J-Set 3.png"
            alt="J-Set 3"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 3 Image (Inferno colormap)
          </figcaption>
        </figure>

<figure>
          <img
            src="J-Set Code 4.png"
            alt="J-Set Code 4"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 4 Code (Inferno colormap)
          </figcaption>
        </figure>	

<p> Here, we have modified z function in line 17. Here, we have changed z*z+c to z*z-1. Note that we changed the colormap to 'inferno'.
The point of this variation was to emphasize the possible color variation; inferno for this Julia Set variation is very different from the previous variation. </p>

        <figure>
          <img
            src="J-Set 4.png"
            alt="J-Set 4"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 4 Image (Inferno colormap)
          </figcaption>
        </figure>
	    
figure>
          <img
            src="J-Set Code 5.png"
            alt="J-Set Code 5"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 5 Code (gist_rainbow_r colormap)
          </figcaption>
        </figure>	

<p> Here, we have reverted our z function in line 17 back to its original state of z*z+c.
	We have altered the c variable in line 29; our complex number assigned to c now has a real and imaginary part of +0.4. 
	This was inspired by a variation model on Wikipedia, cited in the Works Cited section below (Julia). 	
	Note that we changed the colormap to an intresting 'gist_rainbow_r', which was discovered by an error I made in Colab. </p>

        <figure>
          <img
            src="J-Set 5.png"
            alt="J-Set 5"
            width="600"
            height="400"
            loading="lazy"
          />
          <figcaption>
           Julia Set Variation 5 Image (gist_rainbow_r colormap)
          </figcaption>
        </figure>
	    
	    

	    
      <!-- RESULTS & ANALYSIS SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="results">
      
      
        <h2>Results &amp; Analysis</h2>



      </section>



      <!-- CONCLUSION SECTION -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <!-- -------------------------------------------------------------------------------------------- -->
      <section id="conclusion">
        <h2>Conclusion</h2>
        <p>
          These modifications simply showcase customization to the generously provided lab template, and therefore understanding of how to
	  successfully commit changes to associated code for submission to the correlating Lab Report Template Assignment. Note that this was technically unnecessary, 
	  since instructions explicitly state that an unedited version of this template is an acceptable submission.
      </section>

     
     
     
   
     
     
     
  </main>

<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
</body>
</html>
